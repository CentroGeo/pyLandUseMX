[
  {
    "objectID": "api/descargas.html",
    "href": "api/descargas.html",
    "title": "Descargas",
    "section": "",
    "text": "Warning\n\n\n\nTodas las funciones de este módulo toman como entrada el path a donde se van a descargar los datos. El valor por defecto es DOWNLOAD_PATH que es un directorio adentro del directorio de instalación de la librería, es recomendable pasar un path al usar estas funciones."
  },
  {
    "objectID": "api/descargas.html#descarga_denue",
    "href": "api/descargas.html#descarga_denue",
    "title": "Descargas",
    "section": "descarga_denue",
    "text": "descarga_denue\nEsta función descarga diferentes bases preprocesadas del DENUE. En general el procesamiento involucra integrar los sectores en una base única y homogeneizar los nombres de los campos.\nLa función admite un parámetro que controla cuál base se descarga, toma en cuenta que la base completa es MUY grande.\n\nsource\n\ndescarga_denue\n\n descarga_denue\n                 (path:Union[str,pathlib.Path]='/home/runner/work/datos/de\n                 scargas', tipo:str='zmvm_2022')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\ntipo\nstr\nzmvm_2022\nQué archivo vamos a descargar: ejemplo, zmvm_2022, zmvm_full, mexico_2022, mexico_full\n\n\nReturns\nNone\n\n\n\n\n\n\npth = descarga_denue(tipo='ejemplo')\npth\n\nEl archivo ya está descargado\n\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/ejemplo_denue.gpkg'"
  },
  {
    "objectID": "api/descargas.html#descarga_redes",
    "href": "api/descargas.html#descarga_redes",
    "title": "Descargas",
    "section": "descarga_redes",
    "text": "descarga_redes\nEsta función descarga un Geopackage con la red de transporte importada de OpenStreetMap.\nNota: En este momento la red sólo está disponible para la Zona Metropolitana de la Ciudad de México.\n\nsource\n\ndescarga_redes\n\n descarga_redes\n                 (path:Union[str,pathlib.Path]='/home/runner/work/datos/de\n                 scargas')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\n\n\npth = descarga_redes()\npth\n\nEl archivo ya está descargado\n\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/red_zmvm.gpkg'"
  },
  {
    "objectID": "api/descargas.html#descarga_poligonos_ciudades",
    "href": "api/descargas.html#descarga_poligonos_ciudades",
    "title": "Descargas",
    "section": "descarga_poligonos_ciudades",
    "text": "descarga_poligonos_ciudades\nEsta función descarga las slhuetas de las 100 ciudades más grandes de México (SUN, 2016)\n\nsource\n\ndescarga_poligonos_ciudades\n\n descarga_poligonos_ciudades\n                              (path:Union[str,pathlib.Path]='/home/runner/\n                              work/datos/descargas')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\n\n\npth = descarga_poligonos_ciudades()\npth\n\nEl archivo ya está descargado\n\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/silhuetas.shp.zip'"
  },
  {
    "objectID": "api/descargas.html#descarga_colonias_cdmx",
    "href": "api/descargas.html#descarga_colonias_cdmx",
    "title": "Descargas",
    "section": "descarga_colonias_cdmx",
    "text": "descarga_colonias_cdmx\n\nsource\n\ndescarga_colonias_cdmx\n\n descarga_colonias_cdmx\n                         (path:Union[str,pathlib.Path]='/home/runner/work/\n                         datos/descargas')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\n\n\npth = descarga_colonias_cdmx()\npth\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/colonias_cdmx.zip'"
  },
  {
    "objectID": "api/descargas.html#descarga-manzanas",
    "href": "api/descargas.html#descarga-manzanas",
    "title": "Descargas",
    "section": "Descarga manzanas",
    "text": "Descarga manzanas\n\n\n\n\n\n\nWarning\n\n\n\nPor lo pronto sólo proveemos un archivo de ejemplo con manzanas de la CDMX, más adelante implementaremos formas de descargar otras entidades, ciudades y polígonos arbitrarios.\n\n\n\nsource\n\ndescarga_manzanas_ejemplo\n\n descarga_manzanas_ejemplo\n                            (path:Union[str,pathlib.Path]='/home/runner/wo\n                            rk/datos/descargas')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\n\n\npth = descarga_manzanas_ejemplo()\npth\n\nEl archivo ya está descargado\n\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/manzanas_ejemplo.zip'"
  },
  {
    "objectID": "api/descargas.html#descarga_raster_ejemplo",
    "href": "api/descargas.html#descarga_raster_ejemplo",
    "title": "Descargas",
    "section": "descarga_raster_ejemplo",
    "text": "descarga_raster_ejemplo\nEsto descarga un raster que solo se usa como ejemplo en coberturas\n\nsource\n\ndescarga_raster_ejemplo\n\n descarga_raster_ejemplo\n                          (path:Union[str,pathlib.Path]='/home/runner/work\n                          /datos/descargas')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nUnion\n/home/runner/work/datos/descargas\n¿Dónde guardamos el archivo?\n\n\n\n\npth = descarga_raster_ejemplo()\npth\n\n'/home/plablo/git/pyLandUseMX/datos/descargas/raster_ejemplo.tif'"
  },
  {
    "objectID": "api/descargas.html#descarga_datos_completos",
    "href": "api/descargas.html#descarga_datos_completos",
    "title": "Descargas",
    "section": "descarga_datos_completos",
    "text": "descarga_datos_completos\nEsta función llama a todas las anmteriores para descargar todos los datos.\n\nsource\n\ndescarga_datos_completos\n\n descarga_datos_completos ()\n\ndescarga_datos_completos()"
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Tutoriales",
    "section": "",
    "text": "Title\n\n\nDescription\n\n\n\n\n\n\nAnálisis\n\n\nImplementaciones de métodos y algoritmos para analizar el uso de suelo y la estructura urbana.\n\n\n\n\nDenue\n\n\nFunciones para utilizar datos del DENUE en estudios de Uso de Suelo.\n\n\n\n\nDescargas\n\n\nFunciones para descargar, procesar y actualizar las fuentes de datos que se usan en la librería.\n\n\n\n\nUso de Suelo\n\n\nClases y métodos para extraer y procesar información sobre el uso de suelo.\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "api/denue.html",
    "href": "api/denue.html",
    "title": "Denue",
    "section": "",
    "text": "El DENUE es una fuente de información muy importante para construir bases de datos de Uso de Suelo observado en México. Contiene información básica sobre las unidades económicas clasiificadas de acuerdo al sistema SCIAN. Esta clave nos permite extraer de forma fácil diferentes tipos de unidades.\nEste módulo permite operar sobre la base del DENUE para obtener datos que sirvan para modelar el uso de suelo.\nLa clase Denue es la interfaz directa para interactuar con la base de datos.\nsource"
  },
  {
    "objectID": "api/denue.html#filtrar-por-clave-scian",
    "href": "api/denue.html#filtrar-por-clave-scian",
    "title": "Denue",
    "section": "Filtrar por clave SCIAN",
    "text": "Filtrar por clave SCIAN\nLo primero que podemos hacer utilizando estos datos es filtrar las filas utilizando la clave SCIAN. Esta clave está compuesta por 6 caractéres que identifican de forma jerárquica sectores, subsectores y actividades económicas. La estructura completa de la clave se puede consultar aquí.\nLa clase Denue implementa el método filtra_scian que admite una lista de códigos SCIAN,la función regresa un objeto de la misma clase sólo con las filas que correspondan al filtro especificado.\nCada elemento de la lista de claves puede tener un largo arbitrario (menor a 6 caractéres) y el filtro regresará las filas que empiecen con esos caractéres.\n\nsource\n\nDenue.filtra_scian\n\n Denue.filtra_scian (filtro:list, categoria:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfiltro\nlist\n\nLista con las claves a filtrar\n\n\ncategoria\nstr\nNone\nSi se especifica agregamos una columna Categoría\n\n\nReturns\nDenue\n\ny la populamos con el valor especificado\n\n\n\nDigamos que queremos encontrar los bancos, es decir, los lugares donde un ciudadano común y corriente puede ir a obtener diferentes tipos de servicios financieros. Estos establecimiento corresponden a la clave 522110, es decir: Instituciones de intermediación crediticia y financiera no bursátil:: Banca Múltiple\n\nbancos = denue.filtra_scian(['522110'])\nbancos.datos.head()\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      raz_social\n      codigo_act\n      nombre_act\n      per_ocu\n      tipoCenCom\n      cve_ent\n      cve_mun\n      cve_loc\n      ageb\n      manzana\n      index_right\n      OBJECTID\n      Shape_Leng\n      NOM_CIUDAD\n      Shape_Le_1\n      Shape_Area\n      CVE_SUN\n      SUN\n      geometry\n    \n  \n  \n    \n      9\n      HSBC MEXICO\n      BANCO HSBC MEXICO\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      017\n      0001\n      0140\n      001\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.07429 19.44325)\n    \n    \n      62\n      BANORTE/IXE\n      BANCO BANORTE IXE\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      15\n      058\n      0003\n      1842\n      001\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.01810 19.42340)\n    \n    \n      104\n      BBVA BANCOMER\n      BANCO BBVA BANCOMER\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      15\n      121\n      0001\n      2494\n      004\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.21454 19.70071)\n    \n    \n      167\n      CAJERO AUTOMÁTICO BANCOPPEL\n      BANCO BANCOPPEL\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      15\n      033\n      0001\n      1716\n      004\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.02541 19.52982)\n    \n    \n      177\n      CAJERO AUTOMÁTICO CITIBANAMEX\n      BANCO CITIBANAMEX\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      007\n      0001\n      2475\n      005\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.09467 19.37080)\n    \n  \n\n\n\n\nEse fue el caso más sencillo, pero también podríamos localizar todos los lugares en los que podría trabajar un banquero, no sólo bancos de primer piso sino instituciones financieras en general.\n\nfinancieras = denue.filtra_scian(['522110', '5222'])\nfinancieras.datos.tail()\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      raz_social\n      codigo_act\n      nombre_act\n      per_ocu\n      tipoCenCom\n      cve_ent\n      cve_mun\n      cve_loc\n      ageb\n      manzana\n      index_right\n      OBJECTID\n      Shape_Leng\n      NOM_CIUDAD\n      Shape_Le_1\n      Shape_Area\n      CVE_SUN\n      SUN\n      geometry\n    \n  \n  \n    \n      99870\n      SANTANDER\n      BANCO SANTANDER\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      006\n      0001\n      0147\n      001\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.09996 19.40536)\n    \n    \n      99871\n      CAJERO AUTOMÁTICO SANTANDER\n      BANCO SANTANDER\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      014\n      0001\n      0793\n      022\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.18051 19.36955)\n    \n    \n      99895\n      BANORTE/IXE\n      BANCO BANORTE IXE\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      016\n      0001\n      1175\n      015\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.18490 19.40710)\n    \n    \n      99914\n      CAJERO AUTOMÁTICO SCOTIABANK INVERLAT\n      BANCO SCOTIABANK INVERLAT\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      003\n      0001\n      0145\n      010\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.16168 19.35014)\n    \n    \n      99998\n      BANCO SANTANDER\n      BANCO SANTANDER SA\n      522110\n      Banca múltiple\n      0 a 5 personas\n      None\n      09\n      003\n      0001\n      1105\n      016\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.18993 19.30272)\n    \n  \n\n\n\n\nTambién podemos agregar una columna Categoria a los datos y popularla con el valor que deseemos. Esto puede resultar útil para producir más adelante agregados de diferentes actividades.\n\nfinancieras = denue.filtra_scian(['522110', '5222'], categoria='Financieras')\nfinancieras.datos[['codigo_act', 'Categoria']].tail()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      Categoria\n    \n  \n  \n    \n      99870\n      522110\n      Financieras\n    \n    \n      99871\n      522110\n      Financieras\n    \n    \n      99895\n      522110\n      Financieras\n    \n    \n      99914\n      522110\n      Financieras\n    \n    \n      99998\n      522110\n      Financieras"
  },
  {
    "objectID": "api/denue.html#agregar-en-categorías-de-uso-de-suelo",
    "href": "api/denue.html#agregar-en-categorías-de-uso-de-suelo",
    "title": "Denue",
    "section": "Agregar en categorías de Uso de Suelo",
    "text": "Agregar en categorías de Uso de Suelo\nEn general las claves SCIAN no corresponden directamente con los usos de suelo que queremos usar en una investigación en específico. Por ejemplo, en diferentes tipos de estudios urbanos queremos obtener la cantidad de unidades que corresponden a cuestiones como oficinas, manufacturas y comercios al pormenor. Estas categorías no corresponden a claves SCIAN únicas sino que agrupan diferentes claves en una sola categoría de uso de suelo.\nPara acomodar este flujo de trabajo, la clase Denue incorpora el método agrega_en_usos que toma un diccionario con el nombre del uso asociado a una lista de expresiones regulares que buscan las claves SCIAN que se quieren asociar a dicho uso.\n\nsource\n\nDenue.agrega_en_usos\n\n Denue.agrega_en_usos (categorias:dict, columna:str='Categoria')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncategorias\ndict\n\nDiccionario con la asociación entre cadenas de búsqueda en codigo_act y categorías de Uso de Suelo\n\n\ncolumna\nstr\nCategoria\nNombre de la columna en la que se va a guardar la categoría\n\n\nReturns\nDenue\n\n\n\n\n\n\ncategorias = {\n    'Manufacturas': ['^31.*5$', '^32.*5$', '^33.*5$'],\n    'Oficinas': ['^51', '^521', '^523', '^524', '^5312', '^5313', '^541', '^55'],\n    'Comercio': ['^46[123456]']\n}\nusos = denue.agrega_en_usos(categorias)\nusos.datos.loc[~usos.datos.Categoria.isnull()].head()\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      raz_social\n      codigo_act\n      nombre_act\n      per_ocu\n      tipoCenCom\n      cve_ent\n      cve_mun\n      cve_loc\n      ageb\n      ...\n      index_right\n      OBJECTID\n      Shape_Leng\n      NOM_CIUDAD\n      Shape_Le_1\n      Shape_Area\n      CVE_SUN\n      SUN\n      geometry\n      Categoria\n    \n  \n  \n    \n      1\n      TIENDA NATURISTA EL ARTE DE LA NATURALEZA\n      None\n      464113\n      Comercio al por menor de productos naturistas,...\n      0 a 5 personas\n      None\n      09\n      007\n      0001\n      1814\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.06312 19.33782)\n      Comercio\n    \n    \n      3\n      SIN NOMBRE\n      None\n      461130\n      Comercio al por menor de frutas y verduras fre...\n      0 a 5 personas\n      None\n      09\n      008\n      0001\n      0423\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.25436 19.30129)\n      Comercio\n    \n    \n      4\n      ADMINISTRACION MERCADO CONCENTRACION VOCEADORES\n      GOBIERNO DE LA CIUDAD DE MEXICO\n      531311\n      Servicios de administración de bienes raíces\n      0 a 5 personas\n      MERCADO PUBLICO\n      09\n      007\n      0001\n      2371\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.03318 19.38744)\n      Oficinas\n    \n    \n      6\n      ABARROTES LA TIA\n      None\n      461110\n      Comercio al por menor en tiendas de abarrotes,...\n      0 a 5 personas\n      None\n      15\n      121\n      0001\n      1763\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.19269 19.58976)\n      Comercio\n    \n    \n      7\n      BIZUTERIA SIN NOMBRE\n      None\n      463215\n      Comercio al por menor de bisutería y accesorio...\n      0 a 5 personas\n      None\n      15\n      122\n      0001\n      0847\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-98.94058 19.31219)\n      Comercio\n    \n  \n\n5 rows × 21 columns"
  },
  {
    "objectID": "api/denue.html#pesos",
    "href": "api/denue.html#pesos",
    "title": "Denue",
    "section": "Pesos",
    "text": "Pesos\nEl DENUE contiene los puntos de las actividades económicas y algunas variables asociadas. Una de las más importantes para estudios de uso de suelo es el personal ocupado en cada actividad, esta información aparece en el DENUE como rangos:\n\nusos.datos.per_ocu.unique()\n\narray(['0 a 5 personas', '6 a 10 personas', '51 a 100 personas',\n       '11 a 30 personas', '101 a 250 personas', '251 y más personas',\n       '31 a 50 personas'], dtype=object)\n\n\nUna forma de asignar pesos que reflejen la cantidad de personas que trabajan en cada unidad económica es a través de un diccionario que relacione la columna per_ocu con el peso que le queremos dar. Para esto tenemos la función pesa_unidades\n\nsource\n\nDenue.pesa_unidades\n\n Denue.pesa_unidades (pesos:dict, columna:str='pesos')\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npesos\ndict\n\nDiccionario con la relación per_ocu: peso asignado\n\n\ncolumna\nstr\npesos\nColumna en donde vamos a guardar los pesos\n\n\nReturns\nDenue\n\n\n\n\n\n\npesos = {\n        '0 a 5 personas': 2,\n        '6 a 10 personas': 8,\n        '11 a 30 personas': 20,\n        '31 a 50 personas': 40,\n        '51 a 100 personas': 75,\n        '101 a 250 personas': 175,\n        '251 y más personas': 300\n        }\nusos = usos.pesa_unidades(pesos)\nusos.datos[['per_ocu', 'pesos']]\n\n\n\n\n\n  \n    \n      \n      per_ocu\n      pesos\n    \n  \n  \n    \n      0\n      0 a 5 personas\n      2\n    \n    \n      1\n      0 a 5 personas\n      2\n    \n    \n      2\n      0 a 5 personas\n      2\n    \n    \n      3\n      0 a 5 personas\n      2\n    \n    \n      4\n      0 a 5 personas\n      2\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      99995\n      0 a 5 personas\n      2\n    \n    \n      99996\n      0 a 5 personas\n      2\n    \n    \n      99997\n      0 a 5 personas\n      2\n    \n    \n      99998\n      0 a 5 personas\n      2\n    \n    \n      99999\n      0 a 5 personas\n      2\n    \n  \n\n100000 rows × 2 columns"
  },
  {
    "objectID": "api/analisis.html",
    "href": "api/analisis.html",
    "title": "Análisis",
    "section": "",
    "text": "El análisis de Canasta de Mercado (o análisis de afinidad) busca encontrar patrones de co-ocurrencia en bases de transacciones. En el caso geográfico, vamos a considerar como transacciones a las unidades espaciales que estemos usando (elementos de una malla, colonias, agebs, etc) y vamos a buscar co-ocurrencias de usos o actividades en nuestras unidades.\nEn general, el análisis de afinidad se divide en dos etapas: la extracción de patrones frecuentes (co-ocurrencias) y la generación de reglas de asosiación a partir de estos patrones. Para la implementación del análisis en esta librería vamos a usar las funciones del paquete mlxtend.\nEl punto de entrada es la Clase Canasta, que contiene tanto los puntos que representan nuestras actividades (equivalentes a los items en la lista de compras) como los polígonos en los que vamos a agregar las transacciones.\nNota: Por lo pronto sólo está implementada usando un soporte de la clase Malla\n\nsource\n\n\n\n Canasta (puntos:geopandas.geodataframe.GeoDataFrame,\n          cobertura:pyLandUseMX.usodesuelo.Soporte)\n\nClase para guardar los elementos básicos del análisis de afinidad.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npuntos\nGeoDataFrame\nLos puntos que representan las actividades o items\n\n\ncobertura\nSoporte\nLos polígonos en los que se agregan los items\n\n\nReturns\nNone\n\n\n\n\nPara ver cómo funciona, vamos a cagar los datos de ejemplo del DENUE, agregarlos por categoría y luego seleccionar únicamente la categoría de Comercio\n\npth = descarga_denue(tipo='ejemplo')\ndenue = Denue.desde_archivo(pth)\ncategorias = {\n    'Manufacturas': ['^31.*5$', '^32.*5$', '^33.*5$'],\n    'Oficinas': ['^51', '^521', '^523', '^524', '^5312', '^5313', '^541', '^55'],\n    'Comercio': ['^46[123456]']\n}\nusos = denue.agrega_en_usos(categorias)\ncomercio = usos.datos.loc[usos.datos.Categoria == 'Comercio']\ncomercio.head()\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      raz_social\n      codigo_act\n      nombre_act\n      per_ocu\n      tipoCenCom\n      cve_ent\n      cve_mun\n      cve_loc\n      ageb\n      ...\n      index_right\n      OBJECTID\n      Shape_Leng\n      NOM_CIUDAD\n      Shape_Le_1\n      Shape_Area\n      CVE_SUN\n      SUN\n      geometry\n      Categoria\n    \n  \n  \n    \n      1\n      TIENDA NATURISTA EL ARTE DE LA NATURALEZA\n      None\n      464113\n      Comercio al por menor de productos naturistas,...\n      0 a 5 personas\n      None\n      09\n      007\n      0001\n      1814\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.06312 19.33782)\n      Comercio\n    \n    \n      3\n      SIN NOMBRE\n      None\n      461130\n      Comercio al por menor de frutas y verduras fre...\n      0 a 5 personas\n      None\n      09\n      008\n      0001\n      0423\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.25436 19.30129)\n      Comercio\n    \n    \n      6\n      ABARROTES LA TIA\n      None\n      461110\n      Comercio al por menor en tiendas de abarrotes,...\n      0 a 5 personas\n      None\n      15\n      121\n      0001\n      1763\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.19269 19.58976)\n      Comercio\n    \n    \n      7\n      BIZUTERIA SIN NOMBRE\n      None\n      463215\n      Comercio al por menor de bisutería y accesorio...\n      0 a 5 personas\n      None\n      15\n      122\n      0001\n      0847\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-98.94058 19.31219)\n      Comercio\n    \n    \n      8\n      FRUTAS Y VERDURAS SIN NOMBRE\n      None\n      461130\n      Comercio al por menor de frutas y verduras fre...\n      0 a 5 personas\n      None\n      15\n      060\n      0001\n      1037\n      ...\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.33855 19.61941)\n      Comercio\n    \n  \n\n5 rows × 21 columns\n\n\n\nAhora construimos la malla a partir de estos puntos e instanciamos la clase\n\nmalla = Malla.desde_capa(comercio.to_crs(32614), 1000)\ncanasta = Canasta(comercio, malla)\ncanasta\n\n<__main__.Canasta>\n\n\n\n\n\nPara asociar los puntos a la malla, la clase Canasta implementa el método asocia, que utiliza por debajo el método agrega_puntos de la clase Malla\n\nsource\n\n\n\n\n Canasta.asocia (campo:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\ncampo\nstr\nColumna de puntos que clasifica a las observaciones\n\n\nReturns\nCanasta\n\n\n\n\nVamos a asociar los puntos a la malla usando la columna codigo_act para obtener todas las ocurrencias de cada actividad en cada elemento de la malla.\n\nasociada = canasta.asocia('codigo_act')\nasociada.malla.datos.head()\n\n\n\n\n\n  \n    \n      \n      grid_id\n      461110\n      461121\n      461122\n      461123\n      461130\n      461140\n      461150\n      461160\n      461170\n      ...\n      466114\n      466211\n      466212\n      466311\n      466312\n      466313\n      466314\n      466319\n      466410\n      geometry\n    \n  \n  \n    \n      0\n      0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      POLYGON ((449355.857 2095991.537, 450355.857 2...\n    \n    \n      1\n      1\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      POLYGON ((449355.857 2096991.537, 450355.857 2...\n    \n    \n      2\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      POLYGON ((449355.857 2097991.537, 450355.857 2...\n    \n    \n      3\n      3\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      POLYGON ((449355.857 2098991.537, 450355.857 2...\n    \n    \n      4\n      4\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      POLYGON ((449355.857 2099991.537, 450355.857 2...\n    \n  \n\n5 rows × 65 columns\n\n\n\n\n\n\nEn su implementación más sencilla, el análisis de afinidad sólo toma en cuenta la ocurrencia de un item en cada transacción, sin importar la cantidad de items. Para eso, la clase Canasta implementa el método codifica_transaccion que simplemente captura a través de un booleano la existencia de cada item en cada renglón.\n\nsource\n\n\n\n\n Canasta.codifica_transaccion ()\n\nEste método regresa un DataFrame con booleanos que representan la existencia de cada _item__ en cada unidad espacial. Noten que perdemos la geometría de la malla pero conservamos el identificador (grid_id) para unirlo después.\nNota: Este método debe aplicarse despues de asociar, de lo contrario se arroja error\n\ncodificada = asociada.codifica_transaccion()\ncodificada.head()\n\n\n\n\n\n  \n    \n      \n      461110\n      461121\n      461122\n      461123\n      461130\n      461140\n      461150\n      461160\n      461170\n      461190\n      ...\n      466113\n      466114\n      466211\n      466212\n      466311\n      466312\n      466313\n      466314\n      466319\n      466410\n    \n    \n      grid_id\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      ...\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n    \n    \n      1\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      ...\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n    \n    \n      2\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      ...\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n    \n    \n      3\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      ...\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n    \n    \n      4\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      ...\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n      False\n    \n  \n\n5 rows × 63 columns\n\n\n\nEste resultado ya se le puede dar como entrada a cualquier algoritmo de asociación de mlxtend. En este caso vamos a usar apriori\n\nasociaciones = apriori(codificada, min_support=0.07, use_colnames=True)\nasociaciones\n\n\n\n\n\n  \n    \n      \n      support\n      itemsets\n    \n  \n  \n    \n      0\n      0.217446\n      (461110)\n    \n    \n      1\n      0.077583\n      (461121)\n    \n    \n      2\n      0.096881\n      (461122)\n    \n    \n      3\n      0.098830\n      (461130)\n    \n    \n      4\n      0.094347\n      (461160)\n    \n    \n      5\n      0.085185\n      (463211)\n    \n    \n      6\n      0.088109\n      (464111)\n    \n    \n      7\n      0.148343\n      (465311)\n    \n    \n      8\n      0.075634\n      (461121, 461110)\n    \n    \n      9\n      0.093177\n      (461122, 461110)\n    \n    \n      10\n      0.094444\n      (461130, 461110)\n    \n    \n      11\n      0.088402\n      (461160, 461110)\n    \n    \n      12\n      0.078460\n      (463211, 461110)\n    \n    \n      13\n      0.084016\n      (464111, 461110)\n    \n    \n      14\n      0.138402\n      (465311, 461110)\n    \n    \n      15\n      0.077096\n      (461122, 465311)\n    \n    \n      16\n      0.076121\n      (461130, 465311)\n    \n    \n      17\n      0.073099\n      (461160, 465311)\n    \n    \n      18\n      0.076023\n      (461122, 465311, 461110)\n    \n    \n      19\n      0.074659\n      (461130, 465311, 461110)\n    \n    \n      20\n      0.071735\n      (461160, 465311, 461110)"
  },
  {
    "objectID": "api/usodesuelo.html",
    "href": "api/usodesuelo.html",
    "title": "Uso de Suelo",
    "section": "",
    "text": "Para trabajar con datos sobre uso de suelo y estructura urbana, necesitamos definir el soporte espacial (entendido como una teselación del espacio de estudio) que va a ser base para estudiar el uso de suelo. Podemos pensar que existen dos tipos generales de soporte espacial: regulares e irregulares. Los soportes regulares cubren el espacio utilizando siempre la misma figura, como en el caso de las mallas rectangulares o hexagonales, por otro lado, los soportes irregulares cubren el espacio con polígonos arbitrarios, como en el caso de los municipios, AGEBs o colonias.\nEn este módulo incluimos clases y métodos que nos permiten trabajar con diferentes tipos de soporte espacial. Estos métodos pueden ser usados de forma directa, creando objetos de las clases Malla o Poligonos para agregar y calcular variables de uso de suelo y medio construido, o a través de la clase UsoDeSuelo que implementa algunas herramientas de análisis.\n\nsource\n\n\n\n Soporte ()\n\nClase abstracta que define la interfaz para los diferentes tipos de Soporte.\n\n\n\nAlgunos tipos de análisis, como las regresiones de uso de suelo para contaminantes atomsféricos, utilizan datos de uso de suelo en mallas. Para este tipo de aplicaciones la librería provee un conjunto de herramientas para crear mallas y agregar datos en ellas.\nEl primer elemento de este módulo es una Clase para contener la funcionalidad que vamos a implementar. Vamos a comenzar por definir la estructura básica de la clase y luego iremos agregando funcionalidad.\n\nsource\n\n\n\n\n Malla (datos:geopandas.geodataframe.GeoDataFrame=None, size:float=1000)\n\nRepresenta una malla para procesar variables de uso de suelo.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndatos\nGeoDataFrame\nNone\nLa malla vectorial\n\n\nsize\nfloat\n1000\nTamaño de los elementos de la malla (en las unidades de la proyección de layer)\n\n\nReturns\nNone\n\n\n\n\n\nLa clase Malla contiene dos campos: size y datos con el tamaño de los elementos de la retícula y el GeoDataFrame con los polígonos de la malla respectivamente. Por lo pronto la clase sólo tiene un classmethod que nos permite construir un objeto a partir de una capa vectorial:\n\nsource\n\n\n\n\n Malla.desde_capa (capa:geopandas.geodataframe.GeoDataFrame, size:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\ncapa\nGeoDataFrame\nLa capa que define la extensión de la malla\n\n\nsize\nfloat\nTamaño de la malla en unidades de la proyección\n\n\n\n\npth = descarga_poligonos_ciudades()\nzmvm = gpd.read_file(pth)\nzmvm = zmvm.loc[zmvm.CVE_SUN == '13']\nmalla = Malla.desde_capa(zmvm, 1000)\nmalla.datos.plot()\n\nEl archivo ya está descargado\n\n\n<AxesSubplot:>\n\n\n\n\n\nPodemos ver la malla superpuesta al polígono que usamos para construirla:\n\nfig, ax = plt.subplots(figsize=(8, 8))\nzmvm.plot(ax=ax)\nmalla.datos.boundary.plot(ax=ax, edgecolor=\"black\", linewidth=0.1)\n\n<AxesSubplot:>\n\n\n\n\n\n\n\nTambién podemos crear una malla a partir de un raster (p. ej. un geotiff), en este se crea una malla con las mismas características que el raster de entrada.\n\nsource\n\n\n\n\n\n Malla.desde_raster (raster:Union[str,pathlib.Path])\n\n\n\n\n\nType\nDetails\n\n\n\n\nraster\nUnion\nEl raster a partir del que vamos a crear la malla.\n\n\n\n\npth_raster = descarga_raster_ejemplo()\nmalla_raster = Malla.desde_raster(pth_raster)\nmalla_raster.datos\n\nEl archivo ya está descargado\nEPSG:4326\n\n\n\n\n\n\n  \n    \n      \n      geometry\n      grid_id\n    \n  \n  \n    \n      0\n      POLYGON ((-99.65011 20.06836, -99.65011 20.059...\n      0\n    \n    \n      1\n      POLYGON ((-99.64113 20.06836, -99.64113 20.059...\n      1\n    \n    \n      2\n      POLYGON ((-99.63215 20.06836, -99.63215 20.059...\n      2\n    \n    \n      3\n      POLYGON ((-99.62317 20.06836, -99.62317 20.059...\n      3\n    \n    \n      4\n      POLYGON ((-99.61418 20.06836, -99.61418 20.059...\n      4\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      14963\n      POLYGON ((-98.63502 18.93649, -98.63502 18.927...\n      14963\n    \n    \n      14964\n      POLYGON ((-98.62604 18.93649, -98.62604 18.927...\n      14964\n    \n    \n      14965\n      POLYGON ((-98.61705 18.93649, -98.61705 18.927...\n      14965\n    \n    \n      14966\n      POLYGON ((-98.60807 18.93649, -98.60807 18.927...\n      14966\n    \n    \n      14967\n      POLYGON ((-98.59909 18.93649, -98.59909 18.927...\n      14967\n    \n  \n\n14968 rows × 2 columns\n\n\n\n\n\n\nsource\n\n\n\n\n\n Malla.to_crs (to_crs:Union[int,str,pyproj.crs.crs.CRS])\n\nSe encarga de transformar de coordenadas.\n\n\n\n\nType\nDetails\n\n\n\n\nto_crs\nUnion\nEl crs al que queremos reproyectar\n\n\nReturns\nMalla\n\n\n\n\n\nmalla_raster_utm = malla_raster.to_crs(32614)\nprint(malla_raster_utm.crs.to_string(), malla_raster.crs)\n\nEPSG:32614 EPSG:4326\n\n\n\n\nAhora vamos a agregar la funcionalidad para agregar una capa de puntos en la Malla.\nNota: el decorador @patch de fastcore.basics nos permite fácilmente agregar funcionalidad a una clase ya definida.\n\nsource\n\n\n\n\n\n Malla.agrega_puntos (puntos:geopandas.geodataframe.GeoDataFrame,\n                      campo:str='cuenta', clasificacion:str=None,\n                      pesos:str=None)\n\nRegresa una Malla con los conteos de puntos en cada elemento.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npuntos\nGeoDataFrame\n\nLa malla en la que se va a agregar\n\n\ncampo\nstr\ncuenta\nNombre del campo en el que se guarda el resultado\n\n\nclasificacion\nstr\nNone\nColumna de puntos que clasifica a las observaciones (ignora campo)\n\n\npesos\nstr\nNone\nColumna con pesos para las unidades\n\n\nReturns\nMalla\n\n\n\n\n\nLa forma más sencilla de usar este método es simplemente agregar todos los puntos de una capa en la Malla.\n\npth = descarga_denue(tipo='ejemplo')\npuntos = gpd.read_file(pth)\nagregado = malla.agrega_puntos(puntos, campo=\"puntos\")\nagregado.datos\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      grid_id\n      puntos\n      geometry\n    \n  \n  \n    \n      0\n      0\n      0.0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n    \n    \n      1\n      1\n      0.0\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n    \n    \n      2\n      2\n      0.0\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n    \n    \n      3\n      3\n      0.0\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n    \n    \n      4\n      4\n      0.0\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      0.0\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n    \n    \n      13746\n      13746\n      0.0\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n    \n    \n      13747\n      13747\n      0.0\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n    \n    \n      13748\n      13748\n      0.0\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n    \n    \n      13749\n      13749\n      0.0\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n    \n  \n\n13750 rows × 3 columns\n\n\n\nLa función regresa una copia del objeto original con el nuevo campo, el objeto original no se modifica:\n\nmalla.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      geometry\n    \n  \n  \n    \n      0\n      0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n    \n    \n      1\n      1\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n    \n    \n      2\n      2\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n    \n    \n      3\n      3\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n    \n    \n      4\n      4\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n    \n    \n      13746\n      13746\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n    \n    \n      13747\n      13747\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n    \n    \n      13748\n      13748\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n    \n    \n      13749\n      13749\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n    \n  \n\n13750 rows × 2 columns\n\n\n\nPodemos hacer un mapa de estos puntos agregados en la malla:\n\nagregado.datos.plot('puntos')\n\n<AxesSubplot:>\n\n\n\n\n\nTambién es posible agregar los puntos de acuerdo a una clasificación previa. Por ejemplo, supongamos que tenemos datos del DENUE clasificados en tipos de usos de suelo como en el módulo denue.\n\npth = descarga_denue(tipo='ejemplo')\ndenue = Denue.desde_archivo(pth)\ncategorias = {\n    'Manufacturas': ['^31.*5$', '^32.*5$', '^33.*5$'],\n    'Oficinas': ['^51', '^521', '^523', '^524', '^5312', '^5313', '^541', '^55'],\n    'Comercio': ['^46[123456]']\n}\nusos = denue.agrega_en_usos(categorias)\nusos.datos.loc[~usos.datos.Categoria.isnull()][['nom_estab', 'codigo_act', 'Categoria']].head()\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      codigo_act\n      Categoria\n    \n  \n  \n    \n      1\n      TIENDA NATURISTA EL ARTE DE LA NATURALEZA\n      464113\n      Comercio\n    \n    \n      3\n      SIN NOMBRE\n      461130\n      Comercio\n    \n    \n      4\n      ADMINISTRACION MERCADO CONCENTRACION VOCEADORES\n      531311\n      Oficinas\n    \n    \n      6\n      ABARROTES LA TIA\n      461110\n      Comercio\n    \n    \n      7\n      BIZUTERIA SIN NOMBRE\n      463215\n      Comercio\n    \n  \n\n\n\n\nEntonces podemos usar la columna Categoria para agregar los puntos en nuestra malla. La sintaxis es casi igual, sólo que en este caso pasamos el nombre de la columna con la que clasificamos las observaciones:\n\nagregado = malla.agrega_puntos(usos.datos, clasificacion='Categoria')\nagregado.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      Comercio\n      Manufacturas\n      Oficinas\n      geometry\n    \n  \n  \n    \n      0\n      0\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n    \n    \n      1\n      1\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n    \n    \n      2\n      2\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n    \n    \n      3\n      3\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n    \n    \n      4\n      4\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n    \n    \n      13746\n      13746\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n    \n    \n      13747\n      13747\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n    \n    \n      13748\n      13748\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n    \n    \n      13749\n      13749\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n    \n  \n\n13750 rows × 5 columns\n\n\n\nTambién podemos usar una columna con pesos para agregar los puntos. Por ejemplo, en el módulo Denue se pueden agregar pesos a las actividades económicas de acuerdo al número de empleados, podemos usar estos pesos para agregar esos datos en una malla.\n\npesos = {\n        '0 a 5 personas': 2,\n        '6 a 10 personas': 8,\n        '11 a 30 personas': 20,\n        '31 a 50 personas': 40,\n        '51 a 100 personas': 75,\n        '101 a 250 personas': 175,\n        '251 y más personas': 300\n        }\nusos_pesos = usos.pesa_unidades(pesos)\nagregado_pesos = malla.agrega_puntos(usos_pesos.datos, clasificacion='Categoria', pesos='pesos')\nagregado_pesos.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      Comercio\n      Manufacturas\n      Oficinas\n      geometry\n    \n  \n  \n    \n      0\n      0\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n    \n    \n      1\n      1\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n    \n    \n      2\n      2\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n    \n    \n      3\n      3\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n    \n    \n      4\n      4\n      0.0\n      0.0\n      0.0\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n    \n    \n      13746\n      13746\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n    \n    \n      13747\n      13747\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n    \n    \n      13748\n      13748\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n    \n    \n      13749\n      13749\n      0.0\n      0.0\n      0.0\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n    \n  \n\n13750 rows × 5 columns\n\n\n\nPodemos comparar el resultado de usar o no los pesos:\n\nfig, (ax0, ax1) = plt.subplots(1,2, figsize=(10,20))\nax0 = agregado_pesos.datos.plot('Oficinas', ax=ax0)\nax0 = ax0.set_title(\"Con pesos\")\nax1 = agregado.datos.plot('Oficinas', ax=ax1)\nax1 = ax1.set_title(\"Sin pesos\")\n\n\n\n\n\n\nAhora vamos a añadir la funcionalidad de agregar líneas en la malla. Lo que vamos a hacer es calcular la longitud de las líneas adentro de cada cuadrado de la retícula y utiliza ese valor en la malla. Sirve, por ejemplo, para calcular la longitud total de un tipo de vialidad en cada elemento de la malla.\n\nsource\n\n\n\n\n\n Malla.agrega_lineas (lineas:geopandas.geodataframe.GeoDataFrame,\n                      campo:str='longitud')\n\nRegresa una Malla con la longitud de las lineas agregadas en cada elemento.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlineas\nGeoDataFrame\n\nLa capa de líneas a agregar\n\n\ncampo\nstr\nlongitud\nNombre del campo en el que se guarda el resultado\n\n\nReturns\nMalla\n\n\n\n\n\nPara probar la función, descargamos la red de OSM y filtramos sólo las vialidades primarias\n\npth = descarga_redes() # nos aseguramos de tener la red\nred = gpd.read_file(pth)\nred = red.loc[red.tag_id.isin([104,108,106,101])]\nred.plot()\n\nEl archivo ya está descargado\n\n\n<AxesSubplot:>\n\n\n\n\n\nCon esta capa podemos probar la función\n\nred_malla = malla.agrega_lineas(red, campo='metros_vialidad')\nred_malla.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      geometry\n      metros_vialidad\n    \n  \n  \n    \n      0\n      0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n      0.0\n    \n    \n      1\n      1\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n      0.0\n    \n    \n      2\n      2\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n      0.0\n    \n    \n      3\n      3\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n      0.0\n    \n    \n      4\n      4\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n      0.0\n    \n    \n      13746\n      13746\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n      0.0\n    \n    \n      13747\n      13747\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n      0.0\n    \n    \n      13748\n      13748\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n      0.0\n    \n    \n      13749\n      13749\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n      0.0\n    \n  \n\n13750 rows × 3 columns\n\n\n\nLa Malla que nos regresa sólo tiene el id de la malla y la longitud de la red dentro de cada elemento de la retícula. Lo podemos ver rápidamente en un mapa\n\nred_malla.datos.plot('metros_vialidad')\n\n<AxesSubplot:>\n\n\n\n\n\nComo cada operación regresa una copia del objeto, podemos encadenar los métodos para ir agregando varias capas en una malla:\n\nmalla_todo = (malla\n             .agrega_puntos(puntos, campo=\"puntos\")\n             .agrega_lineas(red, campo='metros_vialidad')\n             )\nmalla_todo.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      puntos\n      geometry\n      metros_vialidad\n    \n  \n  \n    \n      0\n      0\n      0.0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n      0.0\n    \n    \n      1\n      1\n      0.0\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n      0.0\n    \n    \n      2\n      2\n      0.0\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n      0.0\n    \n    \n      3\n      3\n      0.0\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n      0.0\n    \n    \n      4\n      4\n      0.0\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      0.0\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n      0.0\n    \n    \n      13746\n      13746\n      0.0\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n      0.0\n    \n    \n      13747\n      13747\n      0.0\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n      0.0\n    \n    \n      13748\n      13748\n      0.0\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n      0.0\n    \n    \n      13749\n      13749\n      0.0\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n      0.0\n    \n  \n\n13750 rows × 4 columns\n\n\n\n\n\nAlgunas variables importantes para analizar el uso de suelo vienen contenidas en los Censos de Ppoblación y Vivienda del INEGI. Como esta librería busca permitir al usuario la mayor libertad posible en cuanto a las unidades de análisis que escoja, optamos por desarrollar un método que permite partir de las variables censales a escala de manzana urbana y agregarlas en nuestras coberturas.\nAgregar las manzanas en coberturas arbitrarioas (regulares o no) implica tener una relación entre los elementos de la cobertura y las manzanas, obviamente esto no se puede hacer de forma exacta porque las fronteras de las manzanas y los elementos de la malla no van a coincidir como se puede ver en la siguiente figura:\n\n\n\nSobreposición de manzanas y una malla de 1000 metros\n\n\nPara resolver este problema, la librería va a asignar automáticamente el id del elemento de la malla a todas las manzanas que estén completamente contenidas en un elemento. El problema va a estar cuando una manzana intersecta a más de un elemento de la malla, para estos casos tenemos dos soluciones alternativas:\n\nCentro de celda: se asigna el identificador del elemento de la malla en el que caiga el centro de la manzana\nÁrea máxima: se asigna el identificador del elemento de la malla que contenga una mayor área de la manzana.\n\n\n\n\n\n\n\nWarning\n\n\n\nEstos métodos funcionan solo cuando el tamaño de la malla es, en general, más grande que las manzanas. Cuando la malla es más pequeña que las manzanas no arroja error pero los resultados no son confiables.\n\n\nA partir de esta relación, entonces podemos seleccionar qué variables del Censo queremos agregar en nuestra retícula.\n\n\n\n\n\n\nNote\n\n\n\nPor lo pronto la librería provee unicamente datos del censo a nivel manzana para la Zona Metropolitana del Valle de México, en el futuro cercano incluiremos las principales ciudades del país.\n\n\n\nsource\n\n\n\n\n\n Malla.agrega_manzanas (manzanas:geopandas.geodataframe.GeoDataFrame,\n                        variables:dict, metodo:str='centro')\n\nDebe agregar variables del censo en la Soporte.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmanzanas\nGeoDataFrame\n\nLas manzanas (descarga_manzanas_ejempolo).\n\n\nvariables\ndict\n\nDiccionario de las variables que querems agregar y el método para agregarlas (p, ej. {‘OCUPVIVPAR’:‘sum’})\n\n\nmetodo\nstr\ncentro\ncentro/area, método para resolver sobreposiciones\n\n\nReturns\nMalla\n\n\n\n\n\nVamos a ilustrar el funcionamiento de este método utilizando unos datos del censo a nivel manzana para la CDMX\n\npth = descarga_manzanas_ejemplo()\nmanzanas = gpd.read_file(pth)\nmanzanas.head()\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      CVEGEO\n      VIVPAR_HAB\n      OCUPVIVPAR\n      geometry\n    \n  \n  \n    \n      0\n      0901000010898031\n      22.0\n      93.0\n      POLYGON ((2790204.135 820779.247, 2790125.593 ...\n    \n    \n      1\n      0901000012269024\n      0.0\n      0.0\n      POLYGON ((2791387.916 821465.156, 2791376.215 ...\n    \n    \n      2\n      0901000011472068\n      33.0\n      124.0\n      POLYGON ((2788494.355 822775.106, 2788478.422 ...\n    \n    \n      3\n      0901000011824024\n      95.0\n      340.0\n      POLYGON ((2790870.494 819456.298, 2790862.256 ...\n    \n    \n      4\n      0901000012377004\n      23.0\n      82.0\n      POLYGON ((2792111.138 821977.886, 2792115.437 ...\n    \n  \n\n\n\n\nPodemos agregar la variable VIVPAR_HAB usando la suma y OCUPVIVPAR con el promedio, utilizando el método centro para resolver las sobreposiciones.\n\nmalla_censo = malla.agrega_manzanas(manzanas, \n                                    {'VIVPAR_HAB': 'sum', \n                                    'OCUPVIVPAR': 'mean'}, \n                                    'centro')\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(10,20))\nax1 = malla_censo.datos.plot('VIVPAR_HAB', ax=ax1)\nax1 = ax1.set_title(\"SUM VIVPAR_HAB\")\nax2 = malla_censo.datos.plot('OCUPVIVPAR', ax=ax2)\nax2 = ax2.set_title(\"MEAN OCUPVIVPAR\")\n\n\n\n\nAhora podemos probar el método area y comparar los resultados.\n\nmalla_censo_area = malla.agrega_manzanas(manzanas, \n                                         {'VIVPAR_HAB': 'sum', \n                                         'OCUPVIVPAR': 'mean'}, \n                                         'area')\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(10,20))\nax1 = malla_censo_area.datos.plot('VIVPAR_HAB', ax=ax1)\nax1 = ax1.set_title(\"Método `area` VIVPAR_HAB\")\nax2 = malla_censo.datos.plot('VIVPAR_HAB', ax=ax2)\nax2 = ax2.set_title(\"Método `centro` VIVPAR_HAB\")\n\n\n\n\n\n\nHasta ahora tenemos una representación vectorial de la malla, lo que sirve muy bien para operaciones espaciales con otras capas, pero una representación más natural y que nos permite operar de formas diferentes es la representación raster. En lugar de transformarlas en matrices directamente, vamos a usar xarray para representar nuestra malla como un Dataset de rasters.\n\nsource\n\n\n\n\n\n Malla.to_xarray (campos:list=None)\n\nRegresa un xarray con los campos seleccionados como variables.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncampos\nlist\nNone\nLista de campos a convertir, se convierten en bandas del raster\n\n\n\nLa función sólo toma como entrada los campos que queremos transformar a raster y regresa un xarray con las variables que seleccionamos como Data variables, las coordenadas x y y como Coordinates y en la proyección de la malla que le pasemos.\n\ncube = malla_todo.to_xarray()\ncube\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:          (y: 126, x: 111)\nCoordinates:\n  * y                (y) float64 7.745e+05 7.755e+05 ... 8.985e+05 8.995e+05\n  * x                (x) float64 2.856e+06 2.854e+06 ... 2.746e+06 2.746e+06\n    spatial_ref      int64 0\nData variables:\n    puntos           (y, x) float64 nan nan nan nan nan ... 0.0 0.0 0.0 0.0 nan\n    metros_vialidad  (y, x) float64 nan nan nan nan nan ... 0.0 0.0 0.0 0.0 nanxarray.DatasetDimensions:y: 126x: 111Coordinates: (3)y(y)float647.745e+05 7.755e+05 ... 8.995e+05axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([774500., 775500., 776500., 777500., 778500., 779500., 780500., 781500.,\n       782500., 783500., 784500., 785500., 786500., 787500., 788500., 789500.,\n       790500., 791500., 792500., 793500., 794500., 795500., 796500., 797500.,\n       798500., 799500., 800500., 801500., 802500., 803500., 804500., 805500.,\n       806500., 807500., 808500., 809500., 810500., 811500., 812500., 813500.,\n       814500., 815500., 816500., 817500., 818500., 819500., 820500., 821500.,\n       822500., 823500., 824500., 825500., 826500., 827500., 828500., 829500.,\n       830500., 831500., 832500., 833500., 834500., 835500., 836500., 837500.,\n       838500., 839500., 840500., 841500., 842500., 843500., 844500., 845500.,\n       846500., 847500., 848500., 849500., 850500., 851500., 852500., 853500.,\n       854500., 855500., 856500., 857500., 858500., 859500., 860500., 861500.,\n       862500., 863500., 864500., 865500., 866500., 867500., 868500., 869500.,\n       870500., 871500., 872500., 873500., 874500., 875500., 876500., 877500.,\n       878500., 879500., 880500., 881500., 882500., 883500., 884500., 885500.,\n       886500., 887500., 888500., 889500., 890500., 891500., 892500., 893500.,\n       894500., 895500., 896500., 897500., 898500., 899500.])x(x)float642.856e+06 2.854e+06 ... 2.746e+06axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([2855500., 2854500., 2853500., 2852500., 2851500., 2850500., 2849500.,\n       2848500., 2847500., 2846500., 2845500., 2844500., 2843500., 2842500.,\n       2841500., 2840500., 2839500., 2838500., 2837500., 2836500., 2835500.,\n       2834500., 2833500., 2832500., 2831500., 2830500., 2829500., 2828500.,\n       2827500., 2826500., 2825500., 2824500., 2823500., 2822500., 2821500.,\n       2820500., 2819500., 2818500., 2817500., 2816500., 2815500., 2814500.,\n       2813500., 2812500., 2811500., 2810500., 2809500., 2808500., 2807500.,\n       2806500., 2805500., 2804500., 2803500., 2802500., 2801500., 2800500.,\n       2799500., 2798500., 2797500., 2796500., 2795500., 2794500., 2793500.,\n       2792500., 2791500., 2790500., 2789500., 2788500., 2787500., 2786500.,\n       2785500., 2784500., 2783500., 2782500., 2781500., 2780500., 2779500.,\n       2778500., 2777500., 2776500., 2775500., 2774500., 2773500., 2772500.,\n       2771500., 2770500., 2769500., 2768500., 2767500., 2766500., 2765500.,\n       2764500., 2763500., 2762500., 2761500., 2760500., 2759500., 2758500.,\n       2757500., 2756500., 2755500., 2754500., 2753500., 2752500., 2751500.,\n       2750500., 2749500., 2748500., 2747500., 2746500., 2745500.])spatial_ref()int640crs_wkt :PROJCS[\"International_Terrestrial_Reference_Frame_1992Lambert_Conformal_Conic_2SP\",GEOGCS[\"GCS_International_Terrestrial_Reference_Frame_1992\",DATUM[\"International_Terrestrial_Reference_Frame_1992\",SPHEROID[\"GRS 1980\",6378137,298.257222101,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6651\"]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Lambert_Conformal_Conic_2SP\"],PARAMETER[\"false_easting\",2500000],PARAMETER[\"false_northing\",0],PARAMETER[\"central_meridian\",-102],PARAMETER[\"standard_parallel_1\",17.5],PARAMETER[\"standard_parallel_2\",29.5],PARAMETER[\"Scale_Factor\",1],PARAMETER[\"latitude_of_origin\",12],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :GCS_International_Terrestrial_Reference_Frame_1992horizontal_datum_name :International_Terrestrial_Reference_Frame_1992projected_crs_name :International_Terrestrial_Reference_Frame_1992Lambert_Conformal_Conic_2SPgrid_mapping_name :lambert_conformal_conicstandard_parallel :(17.5, 29.5)latitude_of_projection_origin :12.0longitude_of_central_meridian :-102.0false_easting :2500000.0false_northing :0.0spatial_ref :PROJCS[\"International_Terrestrial_Reference_Frame_1992Lambert_Conformal_Conic_2SP\",GEOGCS[\"GCS_International_Terrestrial_Reference_Frame_1992\",DATUM[\"International_Terrestrial_Reference_Frame_1992\",SPHEROID[\"GRS 1980\",6378137,298.257222101,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6651\"]],PRIMEM[\"Greenwich\",0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Lambert_Conformal_Conic_2SP\"],PARAMETER[\"false_easting\",2500000],PARAMETER[\"false_northing\",0],PARAMETER[\"central_meridian\",-102],PARAMETER[\"standard_parallel_1\",17.5],PARAMETER[\"standard_parallel_2\",29.5],PARAMETER[\"Scale_Factor\",1],PARAMETER[\"latitude_of_origin\",12],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :2856000.0 -1000.0 0.0 774000.0 0.0 1000.0array(0)Data variables: (2)puntos(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :puntoslong_name :puntos_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])metros_vialidad(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :metros_vialidadlong_name :metros_vialidad_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Attributes: (0)\n\n\nPodemos ver el raster correspondiente a cualquiera de las variables\n\ncube.metros_vialidad.plot()\n\n<matplotlib.collections.QuadMesh>\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n\n Malla.copy ()\n\nRegresa una copia del objeto\n\nmalla_copia = malla.copy()\n\n\n\n\nAdemás de calcular este tipo de agregaciones usando mallas regulares, también es importante poder usar unidades espaciales más naturales como por ejemplo Colonias. Para esto, la librería implementa la clase Poligonos que permite agregar los mismos tipos de datos que Mallas pero en Soportes construidas con polígonos de formas arbitrarias.\n\nsource\n\n\n\n\n Poligonos (datos:geopandas.geodataframe.GeoDataFrame, id_col:str,\n            nom_col:str=None)\n\nRepresenta una cobertura de polígonos de forma arbitraria para procesar variables de uso de suelo.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndatos\nGeoDataFrame\n\nLa malla vectorial\n\n\nid_col\nstr\n\nColumna que se va a usar para identificar a cada polígono\n\n\nnom_col\nstr\nNone\nColumna con el nombre de las unidades espaciales\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\n\n\n Poligonos.desde_archivo (path:str, id_col:str, nom_col:str=None,\n                          layer=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nstr\n\nPath al archivo de datos (cualquiera soportado por GeoPandas),\n\n\nid_col\nstr\n\nColumna que se va a usar para identificar a cada polígono\n\n\nnom_col\nstr\nNone\nColumna con el nombre de las unidades espaciales\n\n\nlayer\nNoneType\nNone\nNombre del layer dentro de la fuente de datos.\n\n\n\nLa clase contiene un método para construirla a partir de un archivo (en cualquier formato soportado por Geopandas). Para construir un objeto de esta forma, simplemente le pasamos el path al método y especificamos qué columna deberemos usar como identificador de las unidades espaciales. Si queremos que las unidades conserven un nombre (además del identificador), lo podemos pasar al constructor:\n\npth = descarga_colonias_cdmx()\npoligonos = Poligonos.desde_archivo(pth, 'id', nom_col='nomut')\npoligonos.datos.head()\n\n\n\n\n\n  \n    \n      \n      id\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n  \n\n\n\n\n\n\n\nsource\n\n\n\n\n\n Poligonos.to_crs (to_crs:Union[int,str,pyproj.crs.crs.CRS])\n\nSe encarga de transformar de coordenadas.\n\n\n\n\nType\nDetails\n\n\n\n\nto_crs\nUnion\nEl crs al que queremos reproyectar\n\n\nReturns\nMalla\n\n\n\n\n\npoligonos_4326 = poligonos.to_crs(4326)\nprint(poligonos_4326.crs, poligonos.crs)\n\nepsg:4326 epsg:32614\n\n\n\n\nIgual que con las mallas, tenemos un método para contar puntos adentro de cada unidad.\n\nsource\n\n\n\n\n\n Poligonos.agrega_puntos (puntos:geopandas.geodataframe.GeoDataFrame,\n                          campo:str='cuenta', clasificacion:str=None,\n                          pesos:str=None)\n\nRegresa un Poligonos con los conteos de puntos en cada unidad.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npuntos\nGeoDataFrame\n\nLa malla en la que se va a agregar\n\n\ncampo\nstr\ncuenta\nNombre del campo en el que se guarda el resultado\n\n\nclasificacion\nstr\nNone\nColumna de puntos que clasifica a las observaciones. En este caso se agregan\n\n\npesos\nstr\nNone\nColumna con pesos para las unidades\n\n\nReturns\nPoligonos\n\n\n\n\n\nLa forma más sencilla de usar este método es simplemente agregar todos los puntos de una capa en nuestros polígonos\n\npuntos = gpd.read_file(\"../../datos/points_sample.zip\")\nagregado = poligonos.agrega_puntos(puntos, campo=\"puntos\")\nagregado.datos\n\n\n\n\n\n  \n    \n      \n      id\n      puntos\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      0.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      0.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      0.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      0.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      1.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      0.0\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      0.0\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      0.0\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      0.0\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      0.0\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 4 columns\n\n\n\nTambién, como en el caso de las mallas, podemos usar una columna con la clasificación para agregar los usos en los polígonos. Usando la misma clasificación que usamos arriba:\n\nagregado = poligonos.agrega_puntos(usos.datos, clasificacion='Categoria')\nagregado.datos\n\n\n\n\n\n  \n    \n      \n      id\n      Comercio\n      Manufacturas\n      Oficinas\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      2.0\n      0.0\n      0.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      6.0\n      0.0\n      1.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      4.0\n      0.0\n      0.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      9.0\n      0.0\n      0.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      43.0\n      0.0\n      4.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      5.0\n      0.0\n      0.0\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      0.0\n      0.0\n      0.0\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      0.0\n      0.0\n      0.0\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      4.0\n      0.0\n      0.0\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      0.0\n      0.0\n      1.0\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 6 columns\n\n\n\n\nagregado.datos.plot('Comercio')\n\n<AxesSubplot:>\n\n\n\n\n\nTambién podemos usar una clolumna con pesos para agregar los puntos\n\nagregado_pesos = poligonos.agrega_puntos(usos_pesos.datos, clasificacion='Categoria', pesos='pesos')\nagregado_pesos.datos\n\n\n\n\n\n  \n    \n      \n      id\n      Comercio\n      Manufacturas\n      Oficinas\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      22.0\n      0.0\n      0.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      12.0\n      0.0\n      2.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      14.0\n      0.0\n      0.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      36.0\n      0.0\n      0.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      140.0\n      0.0\n      64.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      10.0\n      0.0\n      0.0\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      0.0\n      0.0\n      0.0\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      0.0\n      0.0\n      0.0\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      8.0\n      0.0\n      0.0\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      0.0\n      0.0\n      2.0\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 6 columns\n\n\n\nVeamos la comparación de usar o no usar los pesos.\n\nfig, (ax0, ax1) = plt.subplots(1,2, figsize=(10,20))\nax0 = agregado_pesos.datos.plot('Oficinas', ax=ax0)\nax0 = ax0.set_title(\"Con pesos\")\nax1 = agregado.datos.plot('Oficinas', ax=ax1)\nax1 = ax1.set_title(\"Sin pesos\")\n\n\n\n\n\n\nIgual que para el caso de Malla, la clase permite agregar líneas en los polígonos, es decir, calcular la cantidad de metros de una capa de líneas que hay adentro de cada elemento de la cobertura de polígonos. En el caso de los polígonos, al ser de forma irregular, tiene sentido calcular la longitud por unidad de área, en lugar de solo la longitud, el método permite ambas cosas, pero el default es calcular por unidad de área\n\nsource\n\n\n\n\n\n Poligonos.agrega_lineas (lineas:geopandas.geodataframe.GeoDataFrame,\n                          campo:str='longitud', proporcion:bool=True)\n\nRegresa un Poligonos con la longitud de las lineas agregadas en cada elemento.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlineas\nGeoDataFrame\n\nLa capa de líneas a agregar\n\n\ncampo\nstr\nlongitud\nNombre del campo en el que se guarda el resultado\n\n\nproporcion\nbool\nTrue\n¿Debemos hacer el cálculo por unidad de área?\n\n\nReturns\nMalla\n\n\n\n\n\nPodemos probar esta función con la misma red que usamos en Section 1.7.1\n\npoligonos_red = poligonos.agrega_lineas(red)\nax = poligonos_red.datos.plot('longitud', legend=True)\n\n\n\n\n\n\nIgual que en el caso de las mallas regulares (Section 1.8.1), es necesario contar con métodos para agregar variables censales en unidades irregulares. Los problemas en este caso son exáctamente los mismos que los que se enfrentan en ese caso y la solución que ofrece la librería es muy similar, en este caso sólo implementamos el método del centro para resolver las sobreposiciones.\n\nsource\n\n\n\n\n\n Poligonos.agrega_manzanas (manzanas:geopandas.geodataframe.GeoDataFrame,\n                            variables:dict)\n\nDebe agregar variables del censo en la Soporte.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmanzanas\nGeoDataFrame\nLas manzanas (descarga_manzanas_ejempolo).\n\n\nvariables\ndict\nDiccionario de las variables que querems agregar y el método para agregarlas (p, ej. {‘OCUPVIVPAR’:‘sum’})\n\n\nReturns\nPoligonos\n\n\n\n\n\nagregado_censo = poligonos.agrega_manzanas(manzanas, {'VIVPAR_HAB': 'sum', \n                                                     'OCUPVIVPAR': 'mean'})\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(10,20))\nax1 = agregado_censo.datos.plot('VIVPAR_HAB', ax=ax1)\nax1 = ax1.set_title(\"SUM VIVPAR_HAB\")\nax2 = agregado_censo.datos.plot('OCUPVIVPAR', ax=ax2)\nax2 = ax2.set_title(\"MEAN OCUPVIVPAR\")\n\n\n\n\n\n\n\nsource\n\n\n\n\n\n Poligonos.copy ()\n\nRegresa una copia del objeto\n\npoligonos.copy()\n\n<__main__.Poligonos>"
  },
  {
    "objectID": "api/usodesuelo.html#usodesuelo",
    "href": "api/usodesuelo.html#usodesuelo",
    "title": "Uso de Suelo",
    "section": "UsoDeSuelo",
    "text": "UsoDeSuelo\nLa clase de suelo parte de un soporte espacial y la definiión de un conjunto de variables de uso de suelo y del medio construido para construir una capa que nos permite calcular diferentes índices y representarlos en maás y gráficas.\n\nsource\n\nUsoDeSuelo\n\n UsoDeSuelo (soporte:__main__.Soporte, vars_uso:Optional[List[int]]=None,\n             vars_mc:Optional[List[int]]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsoporte\nSoporte\n\nEl soporte espacial de la capa\n\n\nvars_uso\nOptional\nNone\nNombres de las columnas del soporte con variables de uso de suelo\n\n\nvars_mc\nOptional\nNone\nNombres de las columnas del soporte con variables del medio construido\n\n\n\nPodemos crear una capa de UsoDeSuelo partiendo únicamente de un Soporte sin ninguna otra variable. Por ejemplo, partiendo de una Malla\n\n\n\n\n\n\nWarning\n\n\n\nSi el Soporte que se usa tiene ya variables calculadas, pero no se especifican como vars_uso o vars_mc estas variables se eliminan de los datos.\n\n\n\nuso_malla = UsoDeSuelo(malla)\nuso_malla.vars_mc\n\n[]\n\n\n\nuso_malla.soporte.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      geometry\n    \n  \n  \n    \n      0\n      0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n    \n    \n      1\n      1\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n    \n    \n      2\n      2\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n    \n    \n      3\n      3\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n    \n    \n      4\n      4\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n    \n    \n      13746\n      13746\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n    \n    \n      13747\n      13747\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n    \n    \n      13748\n      13748\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n    \n    \n      13749\n      13749\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n    \n  \n\n13750 rows × 2 columns\n\n\n\nLo mismo podemos hacer a partir de un objeto de la clase Poligonos. En este caso, si el objeto contiene la propiedad nom_col, esta columna se conserva.\n\nuso_poligonos = UsoDeSuelo(poligonos)\nuso_poligonos.soporte.datos\n\n\n\n\n\n  \n    \n      \n      id\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 3 columns\n\n\n\nTambién podemos partir de un Soporte que ya tenga algunas variables claculadas y usarlas en nuestro objeto. Por ejemplo, para crear una capa de UsoDeSuelo con los datos que calculamos en @secc-malla-puntos solo tenemos que especificar cómo queremos usar las variables.\n\nuso_vars_malla = UsoDeSuelo(agregado, vars_uso=['Comercio', 'Manufacturas', 'Oficinas'])\nuso_vars_malla.soporte.datos\n\n\n\n\n\n  \n    \n      \n      id\n      geometry\n      Comercio\n      Manufacturas\n      Oficinas\n    \n  \n  \n    \n      0\n      1\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n      2.0\n      0.0\n      0.0\n    \n    \n      1\n      2\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n      6.0\n      0.0\n      1.0\n    \n    \n      2\n      3\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n      4.0\n      0.0\n      0.0\n    \n    \n      3\n      4\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n      9.0\n      0.0\n      0.0\n    \n    \n      4\n      5\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n      43.0\n      0.0\n      4.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n      5.0\n      0.0\n      0.0\n    \n    \n      1811\n      1812\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n      0.0\n      0.0\n      0.0\n    \n    \n      1812\n      1813\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n      0.0\n      0.0\n      0.0\n    \n    \n      1813\n      1814\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n      4.0\n      0.0\n      0.0\n    \n    \n      1814\n      1815\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n      0.0\n      0.0\n      1.0\n    \n  \n\n1815 rows × 5 columns\n\n\n\nY las variables quedan agregadas en la lista en la que deben\n\nuso_vars_malla.vars_uso\n\n['Comercio', 'Manufacturas', 'Oficinas']\n\n\nSi no le decimos que queremos usar esas columnas, las elimina.\n\nuso_malla = UsoDeSuelo(agregado)\nuso_malla.soporte.datos\n\n\n\n\n\n  \n    \n      \n      id\n      geometry\n    \n  \n  \n    \n      0\n      1\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 2 columns\n\n\n\n\n\nAgrega puntos\nLa clase UsoDeSuelo permite hacer las mismas agregaciones que las clases Malla y Poligonos, solo recibe un parámetro extra que le indica si son variables de uso de suelo o del medio construido.\n\nsource\n\n\nUsoDeSuelo.agrega_puntos\n\n UsoDeSuelo.agrega_puntos (puntos:geopandas.geodataframe.GeoDataFrame,\n                           campo:str='cuenta', clasificacion:str=None,\n                           pesos:str=None, tipo_var:str='uso')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npuntos\nGeoDataFrame\n\nLa malla en la que se va a agregar\n\n\ncampo\nstr\ncuenta\nNombre del campo en el que se guarda el resultado\n\n\nclasificacion\nstr\nNone\nColumna de puntos que clasifica a las observaciones (ignora campo)\n\n\npesos\nstr\nNone\nColumna con pesos para las unidades\n\n\ntipo_var\nstr\nuso\nuso/mc ¿qué tipo de variable estamos agregando\n\n\nReturns\nUsoDeSuelo\n\n\n\n\n\nAgregar puntos a una capa de UsoDeSuelo funciona de la misma forma que en el caso de Soporte, por ejemplo, partiendo de una capa vacía, podemos agregar los puntos del Denue con categorías de uso de suelo.\n\nusos_malla = UsoDeSuelo(malla)\nusos_malla = usos_malla.agrega_puntos(usos.datos, clasificacion='Categoria', tipo_var='uso')\nusos_malla.vars_uso\n\n['Comercio', 'Oficinas', 'Manufacturas']\n\n\nPodemos hacer axactamente lo mismo partiendo de un soporte de Poligonos\n\nuso_vars_poli = UsoDeSuelo(agregado)\nuso_vars_poli = uso_vars_poli.agrega_puntos(usos.datos, clasificacion='Categoria', tipo_var='uso')\nuso_vars_poli.soporte.datos\n\n\n\n\n\n  \n    \n      \n      id\n      geometry\n      Comercio\n      Oficinas\n      Manufacturas\n    \n  \n  \n    \n      0\n      1\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n      2.0\n      0.0\n      0.0\n    \n    \n      1\n      2\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n      6.0\n      1.0\n      0.0\n    \n    \n      2\n      3\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n      4.0\n      0.0\n      0.0\n    \n    \n      3\n      4\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n      9.0\n      0.0\n      0.0\n    \n    \n      4\n      5\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n      43.0\n      4.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n      5.0\n      0.0\n      0.0\n    \n    \n      1811\n      1812\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n      0.0\n      0.0\n      0.0\n    \n    \n      1812\n      1813\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n      0.0\n      0.0\n      0.0\n    \n    \n      1813\n      1814\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n      4.0\n      0.0\n      0.0\n    \n    \n      1814\n      1815\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n      0.0\n      1.0\n      0.0\n    \n  \n\n1815 rows × 5 columns\n\n\n\nEn este caso tenemos las siguientes variables de uso de suelo\n\nuso_vars_poli.vars_uso\n\n['Comercio', 'Oficinas', 'Manufacturas']\n\n\n\n\nAgregar líneas\n\nsource\n\n\nUsoDeSuelo.agrega_lineas\n\n UsoDeSuelo.agrega_lineas (lineas:geopandas.geodataframe.GeoDataFrame,\n                           campo:str='longitud', tipo_var:str='uso')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlineas\nGeoDataFrame\n\nLa capa de líneas a agregar\n\n\ncampo\nstr\nlongitud\nNombre del campo en el que se guarda el resultado\n\n\ntipo_var\nstr\nuso\nuso/mc ¿qué tipo de variable estamos agregando\n\n\nReturns\nUsoDeSuelo\n\n\n\n\n\nPartiendo de la capa que acabamos de calcular con las variables de uso de suelo agregadas en una malla, podemos agregar ahora la red vial en las variables de medio construido\n\nusos_malla = usos_malla.agrega_lineas(red, campo='metros_vialidad', tipo_var='mc')\nusos_malla.soporte.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      geometry\n      Comercio\n      Oficinas\n      Manufacturas\n      metros_vialidad\n    \n  \n  \n    \n      0\n      0\n      POLYGON ((2745631.810 774927.105, 2746631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      1\n      POLYGON ((2745631.810 775927.105, 2746631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      2\n      POLYGON ((2745631.810 776927.105, 2746631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      3\n      POLYGON ((2745631.810 777927.105, 2746631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      4\n      POLYGON ((2745631.810 778927.105, 2746631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      13745\n      13745\n      POLYGON ((2854631.810 894927.105, 2855631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      13746\n      13746\n      POLYGON ((2854631.810 895927.105, 2855631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      13747\n      13747\n      POLYGON ((2854631.810 896927.105, 2855631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      13748\n      13748\n      POLYGON ((2854631.810 897927.105, 2855631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      13749\n      13749\n      POLYGON ((2854631.810 898927.105, 2855631.810 ...\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n13750 rows × 6 columns\n\n\n\n\nprint(usos_malla.vars_uso, usos_malla.vars_mc)\n\n['Comercio', 'Oficinas', 'Manufacturas'] ['metros_vialidad']\n\n\nPartiendo ahora de la capa con soporte en polígonos\n\nuso_vars_poli = uso_vars_poli.agrega_lineas(red, campo='metros_vialidad', tipo_var='mc')\nuso_vars_poli.soporte.datos\n\n\n\n\n\n  \n    \n      \n      id\n      geometry\n      Comercio\n      Oficinas\n      Manufacturas\n      metros_vialidad\n    \n  \n  \n    \n      0\n      1\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n      2.0\n      0.0\n      0.0\n      0.008404\n    \n    \n      1\n      2\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n      6.0\n      1.0\n      0.0\n      0.001232\n    \n    \n      2\n      3\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n      4.0\n      0.0\n      0.0\n      0.015416\n    \n    \n      3\n      4\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n      9.0\n      0.0\n      0.0\n      0.005071\n    \n    \n      4\n      5\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n      43.0\n      4.0\n      0.0\n      0.009054\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n      5.0\n      0.0\n      0.0\n      0.001214\n    \n    \n      1811\n      1812\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n      0.0\n      0.0\n      0.0\n      0.000000\n    \n    \n      1812\n      1813\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n      0.0\n      0.0\n      0.0\n      0.003104\n    \n    \n      1813\n      1814\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n      4.0\n      0.0\n      0.0\n      0.001591\n    \n    \n      1814\n      1815\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n      0.0\n      1.0\n      0.0\n      0.000000\n    \n  \n\n1815 rows × 6 columns\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLos métodos para agregar conservan las columnas que ya existen en la capa\n\n\n\n\nAgregar variables del censo\n\nsource\n\n\nUsoDeSuelo.agrega_manzanas\n\n UsoDeSuelo.agrega_manzanas (manzanas:geopandas.geodataframe.GeoDataFrame,\n                             variables:dict, tipo_var:str='uso')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmanzanas\nGeoDataFrame\n\nLas manzanas (descarga_manzanas_ejempolo).\n\n\nvariables\ndict\n\nDiccionario de las variables que querems agregar y el método para agregarlas (p, ej. {‘OCUPVIVPAR’:‘sum’})\n\n\ntipo_var\nstr\nuso\nuso/mc ¿qué tipo de variable estamos agregando\n\n\nReturns\nUsoDeSuelo\n\n\n\n\n\nAgregamos variables del Censo en la capa de uso de suelo que construimos usando una malla.\n\nusos_malla = usos_malla.agrega_manzanas(manzanas, \n                                    {'VIVPAR_HAB': 'sum', \n                                    'OCUPVIVPAR': 'mean'},\n                                    tipo_var='uso')\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(10,20))\nax1 = usos_malla.soporte.datos.plot('VIVPAR_HAB', ax=ax1)\nax1 = ax1.set_title(\"SUM VIVPAR_HAB\")\nax2 = usos_malla.soporte.datos.plot('OCUPVIVPAR', ax=ax2)\nax2 = ax2.set_title(\"MEAN OCUPVIVPAR\")\n\n\n\n\nY verificamos las variables que tenemos en uso de suelo y medio construido\n\nprint(usos_malla.vars_uso, usos_malla.vars_mc)\n\n['Comercio', 'Oficinas', 'Manufacturas', 'VIVPAR_HAB', 'OCUPVIVPAR'] ['metros_vialidad']\n\n\nLo mismo podemos hacer para el caso de objetos construidos con soporte en polígonos.\n\nuso_vars_poli = uso_vars_poli.agrega_manzanas(manzanas, \n                                    {'VIVPAR_HAB': 'sum', \n                                    'OCUPVIVPAR': 'mean'},\n                                    tipo_var='uso')\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(10,20))\nax1 = uso_vars_poli.soporte.datos.plot('VIVPAR_HAB', ax=ax1)\nax1 = ax1.set_title(\"SUM VIVPAR_HAB\")\nax2 = uso_vars_poli.soporte.datos.plot('OCUPVIVPAR', ax=ax2)\nax2 = ax2.set_title(\"MEAN OCUPVIVPAR\")\n\n\n\n\nUna vez más, revisamos las variables que tenemos guardadas\n\nprint(uso_vars_poli.vars_uso, uso_vars_poli.vars_mc)\n\n['Comercio', 'Oficinas', 'Manufacturas', 'VIVPAR_HAB', 'OCUPVIVPAR'] ['metros_vialidad']\n\n\n\n\nCalcular mezclas\nDentro del estudio de uso de suelo en ciudades es muy importante calcular índices para estimar la mezcla de usos de suelo. Para esto, la librería nos provee métodos para calcular dos índices muy usados en la literatura: intensidad y entropía. La intensidad mide qué tan usado está el suelo en cada unidad y es simplemente la suma de todos los usos, mientras que la entropía mide qué tan mezclados están los usos, usando la siguiente fórmula:\n\\[\nE = -\\sum _{j} \\frac{p_j*ln(p_j)}{ln(J)}\n\\]\ndonde \\(j\\) es un índice sobre cada tipo diferente de uso de suelo, \\(p_j\\) es la proporción del j-ésimo uso con respecto al total y \\(J\\) es la cantidad de usos de suelo considerados. La entropía varía entre 0 y 1, donde valores cercanos a 1 indican mayor mezcla y cercanos a 0 mayor homogeneidad.\n\nsource\n\n\nUsoDeSuelo.calcula_mezclas\n\n UsoDeSuelo.calcula_mezclas ()\n\nVamos a usar el soporte de polígonos en el que calculamos usos de suelo utilizando pesos para calcular las variables de mezcla\n\nusos_mezcla = UsoDeSuelo(agregado_pesos, vars_uso=['Comercio', 'Oficinas', 'Manufacturas'])\nusos_mezcla = usos_mezcla.calcula_mezclas()\nfig, (ax0, ax1) = plt.subplots(1,2, figsize=(10,20))\nax0 = usos_mezcla.soporte.datos.plot('entropia', ax=ax0)\nax0 = ax0.set_title(\"Entropia\")\nax1 = usos_mezcla.soporte.datos.plot('intensidad', ax=ax1)\nax1 = ax1.set_title(\"Intensidad\")\n\n\n\n\nAdemás, en la propiedad indices de la clase se guardan las columnas con los índices que hemos calculado\n\nusos_mezcla.indices\n\n['entropia', 'intensidad']"
  },
  {
    "objectID": "fuentes/index.html",
    "href": "fuentes/index.html",
    "title": "Tutoriales",
    "section": "",
    "text": "Title\n\n\nDescription\n\n\n\n\n\n\nDatos del Censo\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "fuentes/censo.html",
    "href": "fuentes/censo.html",
    "title": "Datos del Censo",
    "section": "",
    "text": "from pyLandUseMX.descargas import *\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\nimport requests\nimport os"
  },
  {
    "objectID": "fuentes/censo.html#datos-de-ejemplo",
    "href": "fuentes/censo.html#datos-de-ejemplo",
    "title": "Datos del Censo",
    "section": "Datos de ejemplo",
    "text": "Datos de ejemplo\nAquí documentamos el procedimiento para obtener los datos a nivel manzana que se utilizan como ejemplo en Soporte\n\n# Descargamos la geometría de las manzanas\nPath(DOWNLOADS_PATH).mkdir(parents=True, exist_ok=True)\nfname = 'manzanas.gpkg'\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, fname))\nif os.path.exists(absp):\n    print(\"El archivo ya está descargado\")\nelse:\n    url = 'https://www.dropbox.com/s/bzsj7wl4izzdbjh/manzanas_identificadores.gpkg?dl=1'\n    r = requests.get(url, allow_redirects=True)\n    open(absp, 'wb').write(r.content)\n# Leemos la geometría de las manzanas de CDMX\nmanzanas = gpd.read_file(absp)\n# Descargamos los daots del censo\nPath(DOWNLOADS_PATH).mkdir(parents=True, exist_ok=True)\nfname = 'censo_manzanas.zip'\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, fname))\nif os.path.exists(absp):\n    print(\"El archivo ya está descargado\")\nelse:\n    url = 'https://www.dropbox.com/s/hj6d2t9vtbn5qz4/censo_manzanas.zip?dl=1'\n    r = requests.get(url, allow_redirects=True)\n    open(absp, 'wb').write(r.content)\n# Leemos los datos del censo (sólo unas columnas para elejemplo)\ncenso = pd.read_csv(absp, \n                    dtype={'CVEGEO':str, 'colonia_cve': 'Int64'}, \n                    usecols=['CVEGEO', 'OCUPVIVPAR', 'VIVPAR_HAB'])\n\n# Unimos \nmanzanas = manzanas.merge(censo, on='CVEGEO').fillna(0) # Llenamos con 0 los faltantes\nmanzanas = manzanas.drop(columns=['colonia_cve', 'cuadrante_id', 'colonia_nombre', 'AMBITO', 'TIPOMZA'])\nmanzanas.head()\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      CVEGEO\n      geometry\n      VIVPAR_HAB\n      OCUPVIVPAR\n    \n  \n  \n    \n      0\n      0901000010898031\n      POLYGON ((2790204.135 820779.247, 2790125.593 ...\n      22.0\n      93.0\n    \n    \n      1\n      0901000012269024\n      POLYGON ((2791387.916 821465.156, 2791376.215 ...\n      0.0\n      0.0\n    \n    \n      2\n      0901000011472068\n      POLYGON ((2788494.355 822775.106, 2788478.422 ...\n      33.0\n      124.0\n    \n    \n      3\n      0901000011824024\n      POLYGON ((2790870.494 819456.298, 2790862.256 ...\n      95.0\n      340.0\n    \n    \n      4\n      0901000012377004\n      POLYGON ((2792111.138 821977.886, 2792115.437 ...\n      23.0\n      82.0\n    \n  \n\n\n\n\nLo guardamos\n\nmanzanas.to_file(\"../../datos/descargas/manzanas_ejemplo.shp\")"
  },
  {
    "objectID": "fuentes/censo.html#manzanas-zmvm",
    "href": "fuentes/censo.html#manzanas-zmvm",
    "title": "Datos del Censo",
    "section": "Manzanas ZMVM",
    "text": "Manzanas ZMVM\nPara mostrar cómo integrar datos para una Zona Metropolitana completa, vamos a hacer una integración del Censo a nivel manzana para la Zona Metropolitana del Valle de México. Para esto vamos a necesitar tres insumos básicos: el marco geoestadístico (con los datos de las geometrías de las manzanas), los datos del censo a nivel AGEB urbana y la delimitación de las zonas metropolitanas de CONAPO.\nTodos los datos se pueden descargar del sitio de INEGI, para los polígonos de la delimitración de zonas urbanas, la librería provee una función para su descarga.\nDe aquí en adelante vamos a suponer que tenemos los archivos descargados en DOWNLOADS_PATH y que extrajimos del marco censal los datos de manzanas para los estados que nos interesan (CDMX, Hidalgo y Estado de México).\n\nIntegración de manzanas\nAquí vamos a leer las gemetrías de manzanas de cada estado, unirlas en un sólo DataFrame y seleccionar las que intersecten al polígono de la ZMVM.\n\n# Leemos los datos (no queremos todas las columnas)\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'manzanas_cdmx.zip'))\nmanzanas_cdmx = (gpd.read_file(absp)\n                .drop(columns=['CVE_ENT', 'CVE_MUN', 'CVE_LOC', 'CVE_AGEB', 'CVE_MZA']))\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'manzanas_edomex.zip'))\nmanzanas_edomex = (gpd.read_file(absp)\n                .drop(columns=['CVE_ENT', 'CVE_MUN', 'CVE_LOC', 'CVE_AGEB', 'CVE_MZA']))\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'manzanas_hidalgo.zip'))\nmanzanas_hgo = (gpd.read_file(absp)\n                .drop(columns=['CVE_ENT', 'CVE_MUN', 'CVE_LOC', 'CVE_AGEB', 'CVE_MZA']))\n# Concatenamos en un sólo gdf\nmanzanas = pd.concat([manzanas_cdmx, manzanas_edomex, manzanas_hgo])\n# Descargamos los polígonos de las ciudades, seleccionamos la zmvm y seleccionamos las manzanas que intersectan al polígono.\npth = descarga_poligonos_ciudades()\nzmvm = gpd.read_file(pth)\nzmvm = zmvm.loc[zmvm.CVE_SUN == '13'].to_crs(manzanas.crs)\nmanzanas = (manzanas\n            .sjoin(zmvm)\n            .drop(columns=['index_right', 'OBJECTID', 'Shape_Leng', 'NOM_CIUDAD', 'Shape_Le_1', 'Shape_Area', 'CVE_SUN', 'SUN']))\nmanzanas.plot()\n\nEl archivo ya está descargado\n\n\n<AxesSubplot: >\n\n\n\n\n\n\n\nDatos del censo\nYa tenemos integradas las manzanas, ahoratenemos que integrar los datos del Censo. Para el Censo de 2020 INEGI publica un csv con los resultados por AGEB y manzana urbana combinados, entonces tenemos que, además de hacer la concatenación de las bases, seleccionar únicamente los resultados a nivel manzana.\nEntonces, una vez más, suponiendo que tenemos los datos guardados en la carpeta DOWNLOADS_PATH:\n\n# Leemos el archivo\npth = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'conjunto_de_datos_ageb_urbana_09_cpv2020.zip'))\ncenso_cdmx = pd.read_csv(pth, dtype={\"ENTIDAD\":str, \"MUN\": str, \"LOC\":str, \"AGEB\":str, \"MZA\": str})\n# Nos quedamos sólo con las filas que tienen datos de manzanas (no localidad, agebs, etc)\ncenso_cdmx = censo_cdmx.loc[censo_cdmx['MZA'] != '000']\n# Construimos la cvegeo de las manzanas\ncenso_cdmx['CVEGEO'] = censo_cdmx['ENTIDAD'] + censo_cdmx['MUN'] + censo_cdmx['LOC'] + censo_cdmx['AGEB'] + censo_cdmx['MZA']\ncenso_cdmx.head()\n\n\n\n\n\n  \n    \n      \n      ENTIDAD\n      NOM_ENT\n      MUN\n      NOM_MUN\n      LOC\n      NOM_LOC\n      AGEB\n      MZA\n      POBTOT\n      POBFEM\n      ...\n      VPH_CEL\n      VPH_INTER\n      VPH_STVP\n      VPH_SPMVPI\n      VPH_CVJ\n      VPH_SINRTV\n      VPH_SINLTC\n      VPH_SINCINT\n      VPH_SINTIC\n      CVEGEO\n    \n  \n  \n    \n      4\n      09\n      Ciudad de México\n      002\n      Azcapotzalco\n      0001\n      Azcapotzalco\n      0010\n      001\n      159\n      86\n      ...\n      42\n      39\n      18\n      13\n      6\n      *\n      0\n      9\n      0\n      0900200010010001\n    \n    \n      5\n      09\n      Ciudad de México\n      002\n      Azcapotzalco\n      0001\n      Azcapotzalco\n      0010\n      002\n      145\n      80\n      ...\n      38\n      32\n      14\n      12\n      5\n      0\n      0\n      9\n      0\n      0900200010010002\n    \n    \n      6\n      09\n      Ciudad de México\n      002\n      Azcapotzalco\n      0001\n      Azcapotzalco\n      0010\n      003\n      124\n      64\n      ...\n      28\n      25\n      11\n      15\n      7\n      0\n      *\n      6\n      0\n      0900200010010003\n    \n    \n      7\n      09\n      Ciudad de México\n      002\n      Azcapotzalco\n      0001\n      Azcapotzalco\n      0010\n      004\n      158\n      83\n      ...\n      38\n      34\n      14\n      4\n      7\n      0\n      0\n      7\n      0\n      0900200010010004\n    \n    \n      8\n      09\n      Ciudad de México\n      002\n      Azcapotzalco\n      0001\n      Azcapotzalco\n      0010\n      005\n      154\n      86\n      ...\n      42\n      38\n      12\n      5\n      6\n      0\n      0\n      7\n      0\n      0900200010010005\n    \n  \n\n5 rows × 231 columns\n\n\n\nAhora necesitamos corregir los valores nodata y usar los tipos de datos adecuados. Para eso vamos a necesitar el diccionario de datos del Censo, que también se puede descargar de su siio\n\nfname = 'diccionario_datos_ageb_urbana_09_cpv2020.csv'\nabsp = os.path.abspath(os.path.join(DOWNLOADS_PATH, fname))\ndicionario = pd.read_csv(absp, skiprows=3)\ndiccionario = (dicionario\n                .drop(range(0,8))\n                .drop(columns='Núm.')\n                .reset_index(drop=True)\n                .rename({'Mnemónico':'Nombre del Campo'}, axis=1))\ndiccionario\n\n\n\n\n\n  \n    \n      \n      Indicador\n      Descripción\n      Nombre del Campo\n      Rangos\n      Longitud\n    \n  \n  \n    \n      0\n      Población total\n      Total de personas que residen habitualmente en...\n      POBTOT\n      0...999999999\n      9\n    \n    \n      1\n      Población femenina\n      Total de mujeres que residen habitualmente en ...\n      POBFEM\n      0...999999999\n      9\n    \n    \n      2\n      Población masculina\n      Total de hombres que residen habitualmente en ...\n      POBMAS\n      0...999999999\n      9\n    \n    \n      3\n      Población de 0 a 2 años\n      Personas de 0 a 2 años de edad.\n      P_0A2\n      0…999999999\n      9\n    \n    \n      4\n      Población femenina de 0 a 2 años\n      Mujeres de 0 a 2 años de edad.\n      P_0A2_F\n      0.,.999999999\n      9\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      217\n      Viviendas particulares habitadas que disponen ...\n      Viviendas particulares habitadas que tienen co...\n      VPH_CVJ\n      0…999999999\n      9\n    \n    \n      218\n      Viviendas particulares habitadas sin radio ni ...\n      Viviendas particulares habitadas que no cuenta...\n      VPH_SINRTV\n      0…999999999\n      9\n    \n    \n      219\n      Viviendas particulares habitadas sin línea tel...\n      Viviendas particulares habitadas que no cuenta...\n      VPH_SINLTC\n      0…999999999\n      9\n    \n    \n      220\n      Viviendas particulares habitadas sin computado...\n      Viviendas particulares habitadas que no cuenta...\n      VPH_SINCINT\n      0…999999999\n      9\n    \n    \n      221\n      Viviendas particulares habitadas sin tecnologí...\n      Viviendas particulares habitadas que no cuenta...\n      VPH_SINTIC\n      0…999999999\n      9\n    \n  \n\n222 rows × 5 columns\n\n\n\nYa con el diccionario podemos arreglar la base\n\n# Codificamos los Nan\ncenso_cdmx = (censo_cdmx\n              .replace('999999999', np.nan)\n              .replace('99999999', np.nan)\n              .replace('*', np.nan)\n              .replace('N/D', np.nan)) \n\n# Cambiamos los tipos de datos\ncampos_datos = diccionario['Nombre del Campo'].unique()\ncenso_cdmx[campos_datos] = censo_cdmx[campos_datos].astype('float')\ncenso_cdmx.dtypes\n\nENTIDAD         object\nNOM_ENT         object\nMUN             object\nNOM_MUN         object\nLOC             object\n                ...   \nVPH_SINRTV     float64\nVPH_SINLTC     float64\nVPH_SINCINT    float64\nVPH_SINTIC     float64\nCVEGEO          object\nLength: 231, dtype: object\n\n\nHacemos lo mismo para Edomex e Hidalgo\n\n# Leemos el archivo\npth = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'conjunto_de_datos_ageb_urbana_13_cpv2020.zip'))\ncenso_hgo = pd.read_csv(pth, dtype={\"ENTIDAD\":str, \"MUN\": str, \"LOC\":str, \"AGEB\":str, \"MZA\": str})\n# Nos quedamos sólo con las filas que tienen datos de manzanas (no localidad, agebs, etc)\ncenso_hgo = censo_hgo.loc[censo_hgo['MZA'] != '000']\n# Construimos la cvegeo de las manzanas\ncenso_hgo['CVEGEO'] = censo_hgo['ENTIDAD'] + censo_hgo['MUN'] + censo_hgo['LOC'] + censo_hgo['AGEB'] + censo_hgo['MZA']\n# Leemos el archivo\npth = os.path.abspath(os.path.join(DOWNLOADS_PATH, 'conjunto_de_datos_ageb_urbana_15_cpv2020.zip'))\ncenso_mex = pd.read_csv(pth, dtype={\"ENTIDAD\":str, \"MUN\": str, \"LOC\":str, \"AGEB\":str, \"MZA\": str})\n# Nos quedamos sólo con las filas que tienen datos de manzanas (no localidad, agebs, etc)\ncenso_mex = censo_mex.loc[censo_mex['MZA'] != '000']\n# Construimos la cvegeo de las manzanas\ncenso_mex['CVEGEO'] = censo_mex['ENTIDAD'] + censo_mex['MUN'] + censo_mex['LOC'] + censo_mex['AGEB'] + censo_mex['MZA']\n# Codificamos los Nan\ncenso_hgo = (censo_hgo\n              .replace('999999999', np.nan)\n              .replace('99999999', np.nan)\n              .replace('*', np.nan)\n              .replace('N/D', np.nan)) \n\ncenso_hgo[campos_datos] = censo_hgo[campos_datos].astype('float')\ncenso_mex = (censo_mex\n              .replace('999999999', np.nan)\n              .replace('99999999', np.nan)\n              .replace('*', np.nan)\n              .replace('N/D', np.nan)) \n\ncenso_mex[campos_datos] = censo_mex[campos_datos].astype('float')\n\nConcatenamos y unimos a las geometrías que calculamos arriba\n\ncenso = pd.concat([censo_cdmx, censo_hgo, censo_mex])\nmanzanas = (manzanas\n            .merge(censo, on='CVEGEO')\n            .drop(columns=['ENTIDAD', 'NOM_ENT', 'MUN', 'NOM_MUN', 'LOC', 'NOM_LOC', 'AGEB', 'MZA']))\nmanzanas.head()\n\n\n\n\n\n  \n    \n      \n      CVEGEO\n      AMBITO\n      TIPOMZA\n      geometry\n      POBTOT\n      POBFEM\n      POBMAS\n      P_0A2\n      P_0A2_F\n      P_0A2_M\n      ...\n      VPH_TELEF\n      VPH_CEL\n      VPH_INTER\n      VPH_STVP\n      VPH_SPMVPI\n      VPH_CVJ\n      VPH_SINRTV\n      VPH_SINLTC\n      VPH_SINCINT\n      VPH_SINTIC\n    \n  \n  \n    \n      0\n      0901000010898031\n      Urbana\n      Típica\n      POLYGON ((2790204.135 820779.247, 2790125.593 ...\n      93.0\n      56.0\n      37.0\n      4.0\n      NaN\n      3.0\n      ...\n      20.0\n      19.0\n      15.0\n      16.0\n      6.0\n      3.0\n      0.0\n      0.0\n      7.0\n      0.0\n    \n    \n      1\n      0901000012269024\n      Urbana\n      Típica\n      POLYGON ((2791387.916 821465.156, 2791376.215 ...\n      6.0\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      ...\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2\n      0901000011472068\n      Urbana\n      Típica\n      POLYGON ((2788494.355 822775.106, 2788478.422 ...\n      124.0\n      66.0\n      58.0\n      3.0\n      3.0\n      0.0\n      ...\n      25.0\n      29.0\n      25.0\n      22.0\n      9.0\n      8.0\n      0.0\n      NaN\n      7.0\n      0.0\n    \n    \n      3\n      0901000011824024\n      Urbana\n      Típica\n      POLYGON ((2790870.494 819456.298, 2790862.256 ...\n      340.0\n      177.0\n      163.0\n      12.0\n      8.0\n      4.0\n      ...\n      54.0\n      90.0\n      69.0\n      56.0\n      29.0\n      14.0\n      NaN\n      NaN\n      25.0\n      NaN\n    \n    \n      4\n      0901000012377004\n      Urbana\n      Típica\n      POLYGON ((2792111.138 821977.886, 2792115.437 ...\n      82.0\n      41.0\n      41.0\n      NaN\n      0.0\n      NaN\n      ...\n      15.0\n      21.0\n      13.0\n      13.0\n      6.0\n      3.0\n      0.0\n      0.0\n      9.0\n      0.0\n    \n  \n\n5 rows × 226 columns\n\n\n\nAquí ya tenemos todas las manzanas unidas y con datos. Ya sólo hay que exportar.\n\nmanzanas.to_file(\"../../datos/descargas/manzanas_datos.gpkg\", layer='manzanas')"
  },
  {
    "objectID": "tutoriales/index.html",
    "href": "tutoriales/index.html",
    "title": "Tutoriales",
    "section": "",
    "text": "Title\n\n\nDescription\n\n\n\n\n\n\nAgregación de vialidades\n\n\nEn este tutorial vamos a usar el módulo coberturas para agregar la red vial de la CDMX en una retícula.\n\n\n\n\nExtracción de actividades del DENUE\n\n\nEste tutorial cubre el el uso de los módulos denue y coberturas para extraer actividades y agregarlas en polígonos\n\n\n\n\nZona Metropolitana\n\n\nEste tutorial muestra el flujo completo para crear y analizar variables de uso de suelo y estructura urbana para una zoma metropolitana completa, en este caso la Zona Metropolitana del Valle de México.\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "tutoriales/zona_metro.html",
    "href": "tutoriales/zona_metro.html",
    "title": "Zona Metropolitana",
    "section": "",
    "text": "import geopandas as gpd\nimport pandas as pd\nfrom pyLandUseMX.descargas import *\nfrom pyLandUseMX.usodesuelo import *\nfrom pyLandUseMX.denue import *\nimport contextily as cx\nimport os\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "tutoriales/zona_metro.html#malla",
    "href": "tutoriales/zona_metro.html#malla",
    "title": "Zona Metropolitana",
    "section": "Malla",
    "text": "Malla\nLo primero que vamos a hacer es crear la malla en la que estaremos integrando los datos\n\npth = descarga_raster_ejemplo()\nmalla = Malla.desde_raster(pth)\nax = malla.datos.boundary.plot(edgecolor=\"blue\", linewidth=0.07)\nax = cx.add_basemap(ax, crs=malla.crs)\n\nEl archivo ya está descargado\nEPSG:4326"
  },
  {
    "objectID": "tutoriales/zona_metro.html#red",
    "href": "tutoriales/zona_metro.html#red",
    "title": "Zona Metropolitana",
    "section": "Red",
    "text": "Red\nVamos a agregar en nuestra malla tres tipos diferentes de vialidades:\n\nAcceso controlado\nPrimarias\nSecundarias\nResidenciales\n\nCada una de estas corresponde a un conjunto diferente de tag_id en los datos de OSM\n\n# descargamos y leemos la red\npth_red = os.path.join(DOWNLOADS_PATH, \"red_zmvm_completa.gpkg\")\nred = gpd.read_file(pth_red)\n# definimos los tipos de vialidades y filtramos\nid_acceso_c = [100, 101, 102, 103, 104, 105]\nid_primarias = [106, 107]\nid_secundarias = 108\nid_terciarias = 109\nid_residencial = 110\nacceso_controlado = red.loc[red.tag_id.isin(id_acceso_c)]\nprimarias = red.loc[red.tag_id.isin(id_primarias)]\nsecundarias = red.loc[red.tag_id == id_secundarias]\nterciarias = red.loc[red.tag_id == id_terciarias]\nresidenciales = red.loc[red.tag_id == id_residencial]\n\nYa tenemos los datos para cada tipo de vialidad, ahora podemos agregarlos a nuestra malla\n\nmalla = (malla\n         .agrega_lineas(acceso_controlado, campo='Acceso controlado')\n         .agrega_lineas(primarias, campo='Vialidades primarias')\n         .agrega_lineas(secundarias, campo='Vialidades secundarias')\n         .agrega_lineas(terciarias, campo='Vialidades terciarias')\n         .agrega_lineas(residenciales, campo='Calles residenciales'))\nmalla.datos\n\n\n\n\n\n  \n    \n      \n      geometry\n      grid_id\n      Acceso controlado\n      Vialidades primarias\n      Vialidades secundarias\n      Vialidades terciarias\n      Calles residenciales\n    \n  \n  \n    \n      0\n      POLYGON ((-99.65011 20.06836, -99.65011 20.059...\n      0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      POLYGON ((-99.64113 20.06836, -99.64113 20.059...\n      1\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      POLYGON ((-99.63215 20.06836, -99.63215 20.059...\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      POLYGON ((-99.62317 20.06836, -99.62317 20.059...\n      3\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      POLYGON ((-99.61418 20.06836, -99.61418 20.059...\n      4\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      14963\n      POLYGON ((-98.63502 18.93649, -98.63502 18.927...\n      14963\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14964\n      POLYGON ((-98.62604 18.93649, -98.62604 18.927...\n      14964\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14965\n      POLYGON ((-98.61705 18.93649, -98.61705 18.927...\n      14965\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14966\n      POLYGON ((-98.60807 18.93649, -98.60807 18.927...\n      14966\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14967\n      POLYGON ((-98.59909 18.93649, -98.59909 18.927...\n      14967\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n14968 rows × 7 columns\n\n\n\n\nrasters = malla.to_xarray()\n(rasters\n .to_array()\n .plot(col = 'variable', col_wrap=3, figsize=(15, 10)))\n\n<xarray.plot.facetgrid.FacetGrid>"
  },
  {
    "objectID": "tutoriales/zona_metro.html#usos-de-suelo",
    "href": "tutoriales/zona_metro.html#usos-de-suelo",
    "title": "Zona Metropolitana",
    "section": "Usos de suelo",
    "text": "Usos de suelo\nVamos a usar una base con el Denue para toda la ZMVM del 2022.\n\nAgregar categorías de uso de suelo\nAgregar pesos a las unidades\n\n\npth_denue = os.path.join(DOWNLOADS_PATH, 'denue_2022_zmvm_completo.gpkg')\ndenue = Denue.desde_archivo(pth_denue)\ncategorias = {\n    'Manufacturas': ['^31.*5$', '^32.*5$', '^33.*5$'],\n    'Oficinas': ['^51', '^521', '^523', '^524', '^5312', '^5313', '^541', '^55'],\n    'Comercio': ['^46[123456]']\n}\npesos = {\n        '0 a 5 personas': 2,\n        '6 a 10 personas': 8,\n        '11 a 30 personas': 20,\n        '31 a 50 personas': 40,\n        '51 a 100 personas': 75,\n        '101 a 250 personas': 175,\n        '251 y más personas': 300\n        }\nusos = (denue\n        .pesa_unidades(pesos)\n        .agrega_en_usos(categorias))\nusos.datos.loc[~usos.datos.Categoria.isnull()].head()\n\n\n\n\n\n  \n    \n      \n      clee\n      denue_nombre\n      denue_razon_social\n      codigo_act\n      actividad_nombre\n      per_ocu\n      denue_via_tipo\n      denue_via_nombre\n      denue_via_ext1_tipo\n      denue_via_ext1_nombre\n      ...\n      denue_telefono\n      correoelec\n      www\n      tipoUniEco\n      denue_latitud\n      denue_longitud\n      denue_alta\n      geometry\n      pesos\n      Categoria\n    \n  \n  \n    \n      1\n      15096465912000751000000000U3\n      NOVEDADES YULI\n      \n      465912\n      Comercio al por menor de regalos\n      0 a 5 personas\n      AVENIDA\n      INSURGENTES\n      AVENIDA\n      MORELOS\n      ...\n      \n      \n      \n      Fijo\n      19.90871265\n      -99.14674938\n      2019-11\n      POINT (-99.14675 19.90871)\n      2\n      Comercio\n    \n    \n      6\n      09005465912009041000000000U9\n      KAZANA\n      \n      465912\n      Comercio al por menor de regalos\n      0 a 5 personas\n      AVENIDA\n      1-A\n      CALLE\n      32-A\n      ...\n      \n      \n      \n      Fijo\n      19.52497485\n      -99.1695219\n      2019-11\n      POINT (-99.16952 19.52497)\n      2\n      Comercio\n    \n    \n      64\n      09007463310004711000000000U7\n      ZAPATERIA JOS JER\n      \n      463310\n      Comercio al por menor de calzado\n      0 a 5 personas\n      CALLE\n      18\n      CALLE\n      3\n      ...\n      \n      \n      \n      Fijo\n      19.30874225\n      -99.08205671\n      2010-07\n      POINT (-99.08206 19.30874)\n      2\n      Comercio\n    \n    \n      221\n      09015541110023561000000000U6\n      ARRANGOIZ ABOGADOS, S.C.\n      ARRANGOIZ ABOGADOS SC\n      541110\n      Bufetes jurídicos\n      0 a 5 personas\n      \n      Durango 263 Col. Roma Norte\n      \n      \n      ...\n      \n      \n      \n      Fijo\n      19.419205\n      -99.17030486\n      2020-11\n      POINT (-99.17030 19.41921)\n      2\n      Oficinas\n    \n    \n      223\n      09005464111004891000000000U2\n      FARMACIA SAN JOSE\n      \n      464111\n      Farmacias sin minisúper\n      0 a 5 personas\n      CALLE\n      310\n      CALLE\n      317\n      ...\n      5519006147\n      \n      \n      Fijo\n      19.49611382\n      -99.0856781\n      2010-07\n      POINT (-99.08568 19.49611)\n      2\n      Comercio\n    \n  \n\n5 rows × 44 columns\n\n\n\nAhora agregamos las categorías ponderadas a la malla\n\nmalla = malla.agrega_puntos(usos.datos, clasificacion='Categoria', pesos='pesos')\nmalla.datos.head()\n\n\n\n\n\n  \n    \n      \n      grid_id\n      Comercio\n      Manufacturas\n      Oficinas\n      geometry\n      Acceso controlado\n      Vialidades primarias\n      Vialidades secundarias\n      Vialidades terciarias\n      Calles residenciales\n    \n  \n  \n    \n      0\n      0\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.65011 20.06836, -99.65011 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      1\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.64113 20.06836, -99.64113 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      2\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.63215 20.06836, -99.63215 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      3\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.62317 20.06836, -99.62317 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      4\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.61418 20.06836, -99.61418 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      14963\n      14963\n      0.0\n      0.0\n      0.0\n      POLYGON ((-98.63502 18.93649, -98.63502 18.927...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14964\n      14964\n      0.0\n      0.0\n      0.0\n      POLYGON ((-98.62604 18.93649, -98.62604 18.927...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14965\n      14965\n      0.0\n      0.0\n      0.0\n      POLYGON ((-98.61705 18.93649, -98.61705 18.927...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14966\n      14966\n      0.0\n      0.0\n      0.0\n      POLYGON ((-98.60807 18.93649, -98.60807 18.927...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      14967\n      14967\n      0.0\n      0.0\n      0.0\n      POLYGON ((-98.59909 18.93649, -98.59909 18.927...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n14968 rows × 10 columns"
  },
  {
    "objectID": "tutoriales/zona_metro.html#variables-censales",
    "href": "tutoriales/zona_metro.html#variables-censales",
    "title": "Zona Metropolitana",
    "section": "Variables censales",
    "text": "Variables censales\nVamos a agragar algunas variables del censo de población y vivienda.\n\nViviendas habitadas (VIVPAR_HAB)\nViviendas con auto (VPH_AUTOM)\nPoblación total (POBTOT)\n\n\npth_manzanas = os.path.join(DOWNLOADS_PATH, 'manzanas_datos.gpkg')\nmanzanas = gpd.read_file(pth_manzanas)\ncrs_original = malla.crs\nmalla = (malla\n         .to_crs(manzanas.crs)\n         .agrega_manzanas(manzanas, {'VIVPAR_HAB': 'sum',\n                                     'VPH_AUTOM': 'sum', \n                                     'POBTOT': 'sum'}, \n                                    'centro')\n         .to_crs(crs_original)\n        )\nmalla.datos.head()\n\n/home/plablo/git/pyLandUseMX/pyLandUseMX/usodesuelo.py:226: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  sin_asignar['geometry'] = sin_asignar['geometry'].centroid\n\n\n\n\n\n\n  \n    \n      \n      grid_id\n      Comercio\n      Manufacturas\n      Oficinas\n      geometry\n      Acceso controlado\n      Vialidades primarias\n      Vialidades secundarias\n      Vialidades terciarias\n      Calles residenciales\n      VIVPAR_HAB\n      VPH_AUTOM\n      POBTOT\n    \n  \n  \n    \n      0\n      0\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.65011 20.06836, -99.65011 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      1\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.64113 20.06836, -99.64113 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      2\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.63215 20.06836, -99.63215 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      3\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.62317 20.06836, -99.62317 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      4\n      0.0\n      0.0\n      0.0\n      POLYGON ((-99.61418 20.06836, -99.61418 20.059...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0"
  },
  {
    "objectID": "tutoriales/zona_metro.html#cálculo-de-índices",
    "href": "tutoriales/zona_metro.html#cálculo-de-índices",
    "title": "Zona Metropolitana",
    "section": "Cálculo de índices",
    "text": "Cálculo de índices\nAhora vamos a calcular los ínc¿dices de entropía e intensidad utilizando como variables de uso de suelo Manufacturas, Comercio, Oficinas y VIVPAR_HAB el resto de las variables las vamos a guardar como variables de estructura urbana.\n\nus = UsoDeSuelo(malla, \n                vars_uso=['Comercio', 'Manufacturas', 'Oficinas', 'VIVPAR_HAB'], \n                vars_mc=['Acceso controlado', 'Vialidades primarias', 'Vialidades secundarias',\n                        'Vialidades terciarias', 'Calles residenciales', 'VPH_AUTOM', 'POBTOT'])\nus = us.calcula_mezclas()\nfig, (ax0, ax1) = plt.subplots(1,2, figsize=(10,20))\nax0 = us.soporte.datos.plot('entropia', ax=ax0)\nax0 = ax0.set_title(\"Entropia\")\nax1 = us.soporte.datos.plot('intensidad', ax=ax1)\nax1 = ax1.set_title(\"Intensidad\")\n\n\n\n\n\nfig, (ax0, ax1) = plt.subplots(1,2, figsize=(17,34))\nmapea_entropia = us.soporte.datos.loc[us.soporte.datos.entropia > 0]\nax0 = mapea_entropia.plot('entropia', ax=ax0, cmap='YlGn', scheme='quantiles', k=6, legend=True, alpha=0.8)\nax0.set_title(\"Entropia\")\nax0.set_axis_off()\ncx.add_basemap(ax0, crs=malla.crs, source=cx.providers.CartoDB.Voyager)\n\nmapea_intensidad = us.soporte.datos.loc[us.soporte.datos.intensidad > 0]\nax1 = mapea_intensidad.plot('intensidad', ax=ax1, cmap='OrRd', scheme='quantiles', k=6, legend=True, alpha=0.8)\nax1.set_title(\"Intensidad\")\nax1.set_axis_off()\ncx.add_basemap(ax1, crs=malla.crs, source=cx.providers.CartoDB.Voyager)"
  },
  {
    "objectID": "tutoriales/extraccion_actividades.html",
    "href": "tutoriales/extraccion_actividades.html",
    "title": "Extracción de actividades del DENUE",
    "section": "",
    "text": "En este tutorial vamos a usar la librería para extraer algunas actividades específicas y agregarlas por colonias en la CDMX. Las actividades que vamos a extraer son:\nEmpezamos por importar todas las librerías que vamos a usar"
  },
  {
    "objectID": "tutoriales/extraccion_actividades.html#denue",
    "href": "tutoriales/extraccion_actividades.html#denue",
    "title": "Extracción de actividades del DENUE",
    "section": "Denue",
    "text": "Denue\nLos bancos, tiendas de conveniencia, restaurantes y bares los vamos a extraer del DENUE\n\nBancos\nExtraer los bancos es muy fácil, primero nos aseguramos de que estén descargados los datos del DENUE para la Cdmx e instanciamos la clase.\n\npth = descarga_denue()\ndenue = Denue.desde_archivo(pth)\ndenue.datos.head()\n\nEl archivo ya está descargado\n\n\n\n\n\n\n  \n    \n      \n      nom_estab\n      raz_social\n      codigo_act\n      nombre_act\n      per_ocu\n      tipoCenCom\n      cve_ent\n      cve_mun\n      cve_loc\n      ageb\n      manzana\n      index_right\n      OBJECTID\n      Shape_Leng\n      NOM_CIUDAD\n      Shape_Le_1\n      Shape_Area\n      CVE_SUN\n      SUN\n      geometry\n    \n  \n  \n    \n      0\n      COMERCIALIZADORA Y DISTRIBUIDORA DE VÍVERES SA...\n      COMERCIALIZADORA DE VIVERES SA DE CV\n      115113\n      Beneficio de productos agrícolas\n      6 a 10 personas\n      None\n      09\n      017\n      0001\n      0884\n      018\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.06768 19.42209)\n    \n    \n      1\n      CRIADERO DE TRUCHAS\n      None\n      112512\n      Piscicultura y otra acuicultura, excepto camar...\n      0 a 5 personas\n      None\n      09\n      008\n      0081\n      0368\n      800\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.26444 19.28889)\n    \n    \n      2\n      EMPACADORA TEOTIHUACAN\n      EMPACADORA TEOTIHUACAN SA DE CV\n      115113\n      Beneficio de productos agrícolas\n      0 a 5 personas\n      None\n      09\n      006\n      0001\n      0325\n      020\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.07238 19.40144)\n    \n    \n      3\n      FRUTAS CASA GRANDES\n      FRUTAS CASA GRANDE SPR DE RS DE CV\n      115113\n      Beneficio de productos agrícolas\n      0 a 5 personas\n      CENTRAL DE ABASTO\n      09\n      007\n      0001\n      2475\n      005\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.09481 19.37215)\n    \n    \n      4\n      CRIADERO DE TRUCHAS RANCHO LA ROSITA\n      None\n      112512\n      Piscicultura y otra acuicultura, excepto camar...\n      0 a 5 personas\n      None\n      09\n      008\n      0075\n      0368\n      800\n      53\n      54\n      630172.981156\n      Valle de México\n      630.172981\n      781912.110166\n      13\n      13.0\n      POINT (-99.27449 19.28433)\n    \n  \n\n\n\n\nLos bancos los podemos identificar a través de la clave SCIAN 522110 (Instituciones de intermediación crediticia y financiera no bursátil:: Banca Múltiple). Vamos a filtrar los bancos y agregar una columna con la categoría para usarla después cuando agreguemos en colonias\n\nbancos = denue.filtra_scian(['522110'], categoria='Bancos')\nbancos.datos[['codigo_act', 'nom_estab', 'Categoria']].head()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      nom_estab\n      Categoria\n    \n  \n  \n    \n      577280\n      522110\n      BANCO INBURSA AGUILAS AXOMIATLA\n      Bancos\n    \n    \n      577281\n      522110\n      BANCO SANTANDER\n      Bancos\n    \n    \n      577282\n      522110\n      BANCO INBURSA BODEGA AURRERA LA VIRGEN\n      Bancos\n    \n    \n      577283\n      522110\n      BANCO SANTANDER\n      Bancos\n    \n    \n      577284\n      522110\n      BANCO SANTANDER\n      Bancos\n    \n  \n\n\n\n\n\n\nTiendas de conveniencia\nAhora vamos a extraer las tiendas de conveniencia, estas las podemos encontrar en la clave 462112 que corresponde a “Comercio al por menor en minisupers”\n\nconveniencia = denue.filtra_scian(['462112'], categoria='Conveniencia')\nconveniencia.datos[['codigo_act', 'nom_estab', 'Categoria']].head()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      nom_estab\n      Categoria\n    \n  \n  \n    \n      220450\n      462112\n      ABARROTES Y DULCES EDIMART\n      Conveniencia\n    \n    \n      220463\n      462112\n      ABARROTES Y MAS\n      Conveniencia\n    \n    \n      220467\n      462112\n      ABARROTES Y REFRESCOS\n      Conveniencia\n    \n    \n      220517\n      462112\n      ABARROTES Y VINOS AJUSCO\n      Conveniencia\n    \n    \n      220524\n      462112\n      ABARROTES YAZMIN\n      Conveniencia\n    \n  \n\n\n\n\n\n\nRestaurantes\nLos restaurantes los podemos identificar por la clave SCIAN 72251 “Servicios de preparación de alimentos y bebidas alcohólicas y no alcohólicas”\n\nrestaurantes = denue.filtra_scian(['72251'], categoria='Restaurantes')\nrestaurantes.datos[['codigo_act', 'nom_estab', 'Categoria']].head()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      nom_estab\n      Categoria\n    \n  \n  \n    \n      725899\n      722514\n      ANTOJITOS MEXICANOS\n      Restaurantes\n    \n    \n      725900\n      722513\n      ANTOJITOS MEXICANOS\n      Restaurantes\n    \n    \n      725901\n      722513\n      ANTOJITOS MEXICANOS\n      Restaurantes\n    \n    \n      725902\n      722519\n      ANTOJITOS MEXICANOS\n      Restaurantes\n    \n    \n      725903\n      722513\n      ANTOJITOS MEXICANOS\n      Restaurantes\n    \n  \n\n\n\n\n\n\nBares\nLos Bares se identifican con la clave 722412 “Bares, cantinas y similares”\n\nbares = denue.filtra_scian(['722412'], categoria='Bares')\nbares.datos[['codigo_act', 'nom_estab', 'Categoria']].head()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      nom_estab\n      Categoria\n    \n  \n  \n    \n      726067\n      722412\n      AGUAMIEL Y PULQUES\n      Bares\n    \n    \n      726076\n      722412\n      AGUA BENDITA\n      Bares\n    \n    \n      726087\n      722412\n      ADRENALINE WINGS\n      Bares\n    \n    \n      726110\n      722412\n      ACADEMIA MEXICANA DE SOMMELIERS\n      Bares\n    \n    \n      726244\n      722412\n      A DIOS LE PIDO  RESTAURANTE BAR\n      Bares\n    \n  \n\n\n\n\n\n\nEstaciones de policía\nTambién es posible encontrar las estaciones de policía en el Denue usando la clave SCIAN 931410 ” Impartición de justicia y mantenimiento de la seguridad y el orden público”\n\npolicia = denue.filtra_scian(['931410'], categoria='Policía')\npolicia.datos[['codigo_act', 'nom_estab', 'Categoria']].head()\n\n\n\n\n\n  \n    \n      \n      codigo_act\n      nom_estab\n      Categoria\n    \n  \n  \n    \n      988952\n      931410\n      MEDICO LEGISTA COORDINACIÓN TERRITORIAL COYOAC...\n      Policía\n    \n    \n      988953\n      931410\n      MEDICO LEGISTA\n      Policía\n    \n    \n      988956\n      931410\n      MESA DE DERECHOS HUMANOS DEL CEVASEP 1\n      Policía\n    \n    \n      988959\n      931410\n      MINISTERIO PUBLICO AGENCIA COYOACAN 3\n      Policía\n    \n    \n      988960\n      931410\n      MINISTERIO PUBLICO\n      Policía\n    \n  \n\n\n\n\n\n\nAgregar en colonias\nYa tenemos todos los datos que podemos sacar del Denue, ahora vamos a unirlos en un solo DataFrame y utilizar el módulo coberturas para agregarlos en las colonias de la CDMX. Vamos a seleccionar solamente las columnas Categoria y Geometry para después poder combinar estos datos fácilmente con los que obtengamos de otras fuentes.\n\ndatos_denue = pd.concat([bancos.datos, \n                        conveniencia.datos, \n                        restaurantes.datos, \n                        bares.datos,\n                        policia.datos], axis=0)\ndatos_denue = datos_denue.loc[:, ['Categoria', 'geometry']]\ndatos_denue.head()\n\n\n\n\n\n  \n    \n      \n      Categoria\n      geometry\n    \n  \n  \n    \n      577280\n      Bancos\n      POINT (-99.25366 19.34207)\n    \n    \n      577281\n      Bancos\n      POINT (-99.21235 19.31548)\n    \n    \n      577282\n      Bancos\n      POINT (-99.10697 19.32200)\n    \n    \n      577283\n      Bancos\n      POINT (-99.11336 19.39924)\n    \n    \n      577284\n      Bancos\n      POINT (-99.17190 19.39496)\n    \n  \n\n\n\n\nAhora ya podemos fácilmente agregar los datos en las colonias, asegurándonos de descargar los datos de las colonias, creando el objeto de la clase Poligonos y agregando.\n\npth_colonias = descarga_colonias_cdmx()\ncolonias = Poligonos.desde_archivo(pth_colonias, 'id')\ndenue_colonia = colonias.agrega_puntos(datos_denue, clasificacion='Categoria')\ndenue_colonia.datos.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Bancos\n      Bares\n      Conveniencia\n      Policía\n      Restaurantes\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      0.0\n      2.0\n      0.0\n      0.0\n      20.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      0.0\n      0.0\n      2.0\n      0.0\n      28.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      0.0\n      0.0\n      2.0\n      0.0\n      68.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      2.0\n      0.0\n      2.0\n      0.0\n      74.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      90.0\n      12.0\n      6.0\n      0.0\n      286.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2..."
  },
  {
    "objectID": "tutoriales/extraccion_actividades.html#datos-abiertos-cdmx",
    "href": "tutoriales/extraccion_actividades.html#datos-abiertos-cdmx",
    "title": "Extracción de actividades del DENUE",
    "section": "Datos abiertos CDMX",
    "text": "Datos abiertos CDMX\nHasta aquí utilizamos el Denue como fuente de datos, pero también podemos utilizar otras fuentes sin pasar por la clase Denue. Por ejemplo, para obtener los datos de estaciones de metro y metrobús, vamos a utilizar los Datos abiertos de la CDMX\n\nEstaciones de metro\nLas estaciones se pueden descargar de aquí. Vienen dos shapes uno con las líneas y otro con las estaciones, en este caso vamos a usar sólo el de las estaciones.\n\nmetro = gpd.read_file(\"../../datos/descargas/STC_Metro_estaciones_utm14n.zip\")\nmetro\n\n\n\n\n\n  \n    \n      \n      SISTEMA\n      NOMBRE\n      LINEA\n      EST\n      CVE_EST\n      CVE_EOD17\n      TIPO\n      ALCALDIAS\n      AÑO\n      geometry\n    \n  \n  \n    \n      0\n      STC Metro\n      Pantitlán\n      01\n      01\n      STC0101\n      05014\n      Terminal / Transbordo\n      Venustiano Carranza\n      1984\n      POINT Z (-99.07474 19.41633 0.00000)\n    \n    \n      1\n      STC Metro\n      Zaragoza\n      01\n      02\n      STC0102\n      05020\n      Intermedia\n      Venustiano Carranza\n      1969\n      POINT Z (-99.08229 19.41192 0.00000)\n    \n    \n      2\n      STC Metro\n      Gomez Farías\n      01\n      03\n      STC0103\n      05007\n      Intermedia\n      Venustiano Carranza\n      1969\n      POINT Z (-99.09021 19.41648 0.00000)\n    \n    \n      3\n      STC Metro\n      Boulevard Puerto Aéreo\n      01\n      04\n      STC0104\n      05003\n      Intermedia\n      Venustiano Carranza\n      1969\n      POINT Z (-99.09626 19.41994 0.00000)\n    \n    \n      4\n      STC Metro\n      Balbuena\n      01\n      05\n      STC0105\n      05001\n      Intermedia\n      Venustiano Carranza\n      1969\n      POINT Z (-99.10277 19.42336 0.00000)\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      190\n      STC Metro\n      Múzquiz\n      B\n      17\n      STCLB17\n      05185\n      Intermedia\n      Estado de México - Ecatepec\n      2000\n      POINT Z (-99.04207 19.50149 0.00000)\n    \n    \n      191\n      STC Metro\n      Ecatepec\n      B\n      18\n      STCLB18\n      05179\n      Intermedia\n      Estado de México - Ecatepec\n      2000\n      POINT Z (-99.03607 19.51513 0.00000)\n    \n    \n      192\n      STC Metro\n      Olímpica\n      B\n      19\n      STCLB19\n      05188\n      Intermedia\n      Estado de México - Ecatepec\n      2000\n      POINT Z (-99.03334 19.52134 0.00000)\n    \n    \n      193\n      STC Metro\n      Plaza Aragón\n      B\n      20\n      STCLB20\n      05189\n      Intermedia\n      Estado de México - Ecatepec\n      2000\n      POINT Z (-99.03018 19.52848 0.00000)\n    \n    \n      194\n      STC Metro\n      Ciudad Azteca\n      B\n      21\n      STCLB21\n      05177\n      Terminal\n      Estado de México - Ecatepec\n      2000\n      POINT Z (-99.02751 19.53451 0.00000)\n    \n  \n\n195 rows × 10 columns\n\n\n\nVamos a quedarnos sólo cona la columna de geometría y, para poder combinarlos bien con los que obtuvimos arriba del Denue, agreguemos una columna con la categoría a la que corresponden\n\nmetro.loc[:, 'Categoria'] = \"Metro\"\nmetro = metro.loc[:, ['Categoria', 'geometry']]\nmetro.head()\n\n\n\n\n\n  \n    \n      \n      Categoria\n      geometry\n    \n  \n  \n    \n      0\n      Metro\n      POINT Z (-99.07474 19.41633 0.00000)\n    \n    \n      1\n      Metro\n      POINT Z (-99.08229 19.41192 0.00000)\n    \n    \n      2\n      Metro\n      POINT Z (-99.09021 19.41648 0.00000)\n    \n    \n      3\n      Metro\n      POINT Z (-99.09626 19.41994 0.00000)\n    \n    \n      4\n      Metro\n      POINT Z (-99.10277 19.42336 0.00000)\n    \n  \n\n\n\n\n\n\nMetrobús\nAhora hacemos lo mismo con los datos del metrobús que se pueden descargar de aquí. Estos datos vienen en UTM, entonces vamos a necesitar reproyectarlos para después poderlos concatenar con los otros.\n\nmetrobus = gpd.read_file(\"../../datos/descargas/Metrobus_estaciones_rutas_utm14n.zip\")\nmetrobus = metrobus.to_crs(4326)\nmetrobus.loc[:, 'Categoria'] = \"Metrobus\"\nmetrobus = metrobus.loc[:, ['Categoria', 'geometry']]\nmetrobus.head()\n\n\n\n\n\n  \n    \n      \n      Categoria\n      geometry\n    \n  \n  \n    \n      0\n      Metrobus\n      POINT (-99.08367 19.43531)\n    \n    \n      1\n      Metrobus\n      POINT (-99.07725 19.42148)\n    \n    \n      2\n      Metrobus\n      POINT (-99.15242 19.44259)\n    \n    \n      3\n      Metrobus\n      POINT (-99.15245 19.44214)\n    \n    \n      4\n      Metrobus\n      POINT (-99.15327 19.43903)\n    \n  \n\n\n\n\n\n\nAgregar en colonias\nIgual que con los datos anteriores, vamos a concatenar estas dos bases para agregarlas en las colonias\n\ntransporte = pd.concat([metro, metrobus], axis=0)\ntransporte_colonias = colonias.agrega_puntos(transporte, clasificacion='Categoria')\ntransporte_colonias.datos\n\n\n\n\n\n  \n    \n      \n      id\n      Metro\n      Metrobus\n      nomut\n      geometry\n    \n  \n  \n    \n      0\n      1\n      0.0\n      0.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n    \n    \n      1\n      2\n      0.0\n      0.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n    \n    \n      2\n      3\n      1.0\n      0.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n    \n    \n      3\n      4\n      0.0\n      0.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n    \n    \n      4\n      5\n      0.0\n      0.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      0.0\n      0.0\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n    \n    \n      1811\n      1812\n      0.0\n      0.0\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n    \n    \n      1812\n      1813\n      0.0\n      0.0\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n    \n    \n      1813\n      1814\n      0.0\n      0.0\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n    \n    \n      1814\n      1815\n      0.0\n      0.0\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n    \n  \n\n1815 rows × 5 columns"
  },
  {
    "objectID": "tutoriales/extraccion_actividades.html#unir-datos-y-exportar",
    "href": "tutoriales/extraccion_actividades.html#unir-datos-y-exportar",
    "title": "Extracción de actividades del DENUE",
    "section": "Unir datos y exportar",
    "text": "Unir datos y exportar\nYa tenemos las bases agregadas pogracias por recordarme jejeje r colonias que extrajimos de dos fuentes diferentes: el Denue y los Datos Abiertos de la CDMX. Ahora vamos a unir ambas bases y exportar los datos como shapefile.\nEl método Poligonos.agrega_puntos siempre nos regresa los polígonos originales completos, entonces unirlos es sencillo\n\ncompleto = transporte_colonias.datos.merge(denue_colonia.datos[['id','Bancos', 'Bares', 'Conveniencia', 'Policía', 'Restaurantes']], on='id')\ncompleto\n\n\n\n\n\n  \n    \n      \n      id\n      Metro\n      Metrobus\n      nomut\n      geometry\n      Bancos\n      Bares\n      Conveniencia\n      Policía\n      Restaurantes\n    \n  \n  \n    \n      0\n      1\n      0.0\n      0.0\n      AGUILERA\n      POLYGON ((483311.618 2153254.848, 483332.006 2...\n      0.0\n      2.0\n      0.0\n      0.0\n      20.0\n    \n    \n      1\n      2\n      0.0\n      0.0\n      ALDANA\n      POLYGON ((484406.956 2153012.331, 484401.132 2...\n      0.0\n      0.0\n      2.0\n      0.0\n      28.0\n    \n    \n      2\n      3\n      1.0\n      0.0\n      ANGEL ZIMBRON\n      POLYGON ((480013.755 2153003.618, 480063.589 2...\n      0.0\n      0.0\n      2.0\n      0.0\n      68.0\n    \n    \n      3\n      4\n      0.0\n      0.0\n      ARENAL\n      POLYGON ((484061.118 2152622.284, 484061.678 2...\n      2.0\n      0.0\n      2.0\n      0.0\n      74.0\n    \n    \n      4\n      5\n      0.0\n      0.0\n      CENTRO DE AZCAPOTZALCO\n      POLYGON ((480123.402 2154520.928, 480131.648 2...\n      90.0\n      12.0\n      6.0\n      0.0\n      286.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1810\n      1811\n      0.0\n      0.0\n      VILLA PROGRESISTA\n      POLYGON ((474406.945 2140353.439, 474418.850 2...\n      2.0\n      0.0\n      0.0\n      0.0\n      6.0\n    \n    \n      1811\n      1812\n      0.0\n      0.0\n      VILLA SOLIDARIDAD\n      POLYGON ((477048.978 2143204.554, 477054.695 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1812\n      1813\n      0.0\n      0.0\n      VILLA VERDUN\n      POLYGON ((473081.154 2138733.281, 473070.790 2...\n      0.0\n      0.0\n      0.0\n      2.0\n      2.0\n    \n    \n      1813\n      1814\n      0.0\n      0.0\n      ZENON DELGADO\n      POLYGON ((477329.014 2144260.214, 477335.725 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      14.0\n    \n    \n      1814\n      1815\n      0.0\n      0.0\n      ZOTOLTITLA\n      POLYGON ((475172.282 2139719.331, 475190.495 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n1815 rows × 10 columns\n\n\n\n\ncompleto.to_file(\"../../datos/descargas/actividades_cdmx.shp\")\n\n/tmp/ipykernel_14136/2170292792.py:1: UserWarning: Column names longer than 10 characters will be truncated when saved to ESRI Shapefile.\n  completo.to_file(\"../../datos/descargas/actividades_cdmx.shp\")"
  },
  {
    "objectID": "tutoriales/vialidades.html",
    "href": "tutoriales/vialidades.html",
    "title": "Agregación de vialidades",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport geopandas as gpd\nfrom pyLandUseMX.descargas import *\nfrom pyLandUseMX.usodesuelo import *\n\n\nred = gpd.read_file(\"datos/descargas/red_zmvm.gpkg\")\n# zmvm = gpd.read_file(\"datos/descargas/silhuetas.shp.zip\")\n# zmvm = zmvm.loc[zmvm.CVE_SUN == '13']\n# red = red.sjoin(zmvm.to_crs(red.crs))\n\n\nid_acceso_c = [100, 101, 102, 103, 104, 105]\nid_primarias = [106, 107]\nid_secundarias = 108\nid_terciarias = 109\nid_residencial = 110\n\n\nacceso_controlado = red.loc[red.tag_id.isin(id_acceso_c)]\nprimarias = red.loc[red.tag_id.isin(id_primarias)]\nsecundarias = red.loc[red.tag_id == id_secundarias]\nterciarias = red.loc[red.tag_id == id_terciarias]\nresidenciales = red.loc[red.tag_id == id_residencial]\n\n\nmapas = {\n    \"Vialidades de acceso controlado\": {\n        \"datos\":acceso_controlado,\n        \"color\": \"darkred\",\n        \"peso\": 1},\n    \"Vialidades primarias\": {\n        \"datos\":primarias,\n        \"color\": \"tomato\",\n        \"peso\": 0.8},\n    \"Vialidades secundaris\": {\n        \"datos\":secundarias,\n        \"color\": \"chocolate\",\n        \"peso\": 0.6},\n    \"Vialidades terciarias\": {\n        \"datos\":terciarias,\n        \"color\": \"tan\",\n        \"peso\": 0.5},\n    \"Calles residenciales\": {\n        \"datos\":residenciales,\n        \"color\": \"black\",\n        \"peso\": 0.02},\n}\n\n\nfig, axs = plt.subplots(3,2,figsize=(15, 15))\naxs = axs.ravel()\nfor i, (k,v) in enumerate(mapas.items()):\n    ax = v['datos'].plot(ax=axs[i], linewidth=v['peso'], color=v['color'])\n    ax.set_title(k)\n    ax.axis('off')\n\nfig.delaxes(axs[-1])\nplt.subplots_adjust(wspace=0, hspace=0)\n# plt.tight_layout(pad=0.05)\n\n\n\n\n\nmalla = (Malla\n         .desde_capa(red, 1000)\n         .agrega_lineas(acceso_controlado, campo='Acceso controlado')\n         .agrega_lineas(primarias, campo='Vialidades primarias')\n         .agrega_lineas(secundarias, campo='Vialidades secundarias')\n         .agrega_lineas(terciarias, campo='Vialidades terciarias')\n         .agrega_lineas(residenciales, campo='Calles residenciales'))\n\n\nmalla.datos\n\n\n\n\n\n  \n    \n      \n      grid_id\n      geometry\n      Acceso controlado\n      Vialidades primarias\n      Vialidades secundarias\n      Vialidades terciarias\n      Calles residenciales\n    \n  \n  \n    \n      0\n      0\n      POLYGON ((455987.604 2101522.619, 456987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      1\n      POLYGON ((455987.604 2102522.619, 456987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      2\n      POLYGON ((455987.604 2103522.619, 456987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      3\n      POLYGON ((455987.604 2104522.619, 456987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      4\n      POLYGON ((455987.604 2105522.619, 456987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      7609\n      7609\n      POLYGON ((535987.604 2190522.619, 536987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      7610\n      7610\n      POLYGON ((535987.604 2191522.619, 536987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      7611\n      7611\n      POLYGON ((535987.604 2192522.619, 536987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      7612\n      7612\n      POLYGON ((535987.604 2193522.619, 536987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      7613\n      7613\n      POLYGON ((535987.604 2194522.619, 536987.604 2...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n7614 rows × 7 columns\n\n\n\n\nrasters = malla.to_xarray()\n\n\nrasters\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:                 (y: 95, x: 82)\nCoordinates:\n  * y                       (y) float64 2.102e+06 2.102e+06 ... 2.196e+06\n  * x                       (x) float64 5.365e+05 5.355e+05 ... 4.555e+05\n    spatial_ref             int64 0\nData variables:\n    Acceso controlado       (y, x) float64 nan nan nan nan ... 0.0 0.0 0.0 nan\n    Vialidades primarias    (y, x) float64 nan nan nan nan ... 0.0 0.0 0.0 nan\n    Vialidades secundarias  (y, x) float64 nan nan nan nan ... 0.0 0.0 0.0 nan\n    Vialidades terciarias   (y, x) float64 nan nan nan nan ... 0.0 0.0 0.0 nan\n    Calles residenciales    (y, x) float64 nan nan nan nan ... 0.0 0.0 0.0 nanxarray.DatasetDimensions:y: 95x: 82Coordinates: (3)y(y)float642.102e+06 2.102e+06 ... 2.196e+06axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinateunits :metrearray([2101500., 2102500., 2103500., 2104500., 2105500., 2106500., 2107500.,\n       2108500., 2109500., 2110500., 2111500., 2112500., 2113500., 2114500.,\n       2115500., 2116500., 2117500., 2118500., 2119500., 2120500., 2121500.,\n       2122500., 2123500., 2124500., 2125500., 2126500., 2127500., 2128500.,\n       2129500., 2130500., 2131500., 2132500., 2133500., 2134500., 2135500.,\n       2136500., 2137500., 2138500., 2139500., 2140500., 2141500., 2142500.,\n       2143500., 2144500., 2145500., 2146500., 2147500., 2148500., 2149500.,\n       2150500., 2151500., 2152500., 2153500., 2154500., 2155500., 2156500.,\n       2157500., 2158500., 2159500., 2160500., 2161500., 2162500., 2163500.,\n       2164500., 2165500., 2166500., 2167500., 2168500., 2169500., 2170500.,\n       2171500., 2172500., 2173500., 2174500., 2175500., 2176500., 2177500.,\n       2178500., 2179500., 2180500., 2181500., 2182500., 2183500., 2184500.,\n       2185500., 2186500., 2187500., 2188500., 2189500., 2190500., 2191500.,\n       2192500., 2193500., 2194500., 2195500.])x(x)float645.365e+05 5.355e+05 ... 4.555e+05axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinateunits :metrearray([536500., 535500., 534500., 533500., 532500., 531500., 530500., 529500.,\n       528500., 527500., 526500., 525500., 524500., 523500., 522500., 521500.,\n       520500., 519500., 518500., 517500., 516500., 515500., 514500., 513500.,\n       512500., 511500., 510500., 509500., 508500., 507500., 506500., 505500.,\n       504500., 503500., 502500., 501500., 500500., 499500., 498500., 497500.,\n       496500., 495500., 494500., 493500., 492500., 491500., 490500., 489500.,\n       488500., 487500., 486500., 485500., 484500., 483500., 482500., 481500.,\n       480500., 479500., 478500., 477500., 476500., 475500., 474500., 473500.,\n       472500., 471500., 470500., 469500., 468500., 467500., 466500., 465500.,\n       464500., 463500., 462500., 461500., 460500., 459500., 458500., 457500.,\n       456500., 455500.])spatial_ref()int640crs_wkt :PROJCS[\"WGS 84 / UTM zone 14N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-99],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32614\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :WGS 84 / UTM zone 14Ngrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-99.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"WGS 84 / UTM zone 14N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-99],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32614\"]]GeoTransform :537000.0 -1000.0 0.0 2101000.0 0.0 1000.0array(0)Data variables: (5)Acceso controlado(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :Acceso controladolong_name :Acceso controlado_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Vialidades primarias(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :Vialidades primariaslong_name :Vialidades primarias_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Vialidades secundarias(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :Vialidades secundariaslong_name :Vialidades secundarias_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Vialidades terciarias(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :Vialidades terciariaslong_name :Vialidades terciarias_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Calles residenciales(y, x)float64nan nan nan nan ... 0.0 0.0 0.0 nanname :Calles residencialeslong_name :Calles residenciales_FillValue :nanarray([[nan, nan, nan, ..., nan, nan, nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       ...,\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan],\n       [ 0.,  0.,  0., ...,  0.,  0., nan]])Attributes: (0)\n\n\n\nrasters['Acceso controlado'].plot()\n\n<matplotlib.collections.QuadMesh>\n\n\n\n\n\n\n(rasters\n .to_array()\n .plot(col = 'variable', col_wrap=3, figsize=(15, 10)))\n\n<xarray.plot.facetgrid.FacetGrid>"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyLandUseMX",
    "section": "",
    "text": "El uso de suelo es un insumo básico para diferentes investigaciones en el contexto urbano: criminología, movilidad y diseño urbano, por ejemplo, son campos en los que contar con información sobre el uso real del suelo resulta fundamental para realizar investigaciones cuantitativas. Esta librería busca ofrecer diferentes opciones para construir variables e índices para caracterizar el uso de suelo real, es decir el uso observado, en el contexto de las ciudades mexicanas.\nAdemás de mediciones sobre uso de suelo, la librería provee métodos para extraer variables de estructura urbana como mezcla e intensidad de uso de suelo. También implementa algunas herramientas básicas de análisis para extraer patrones y relaciones en diferentes escalas.\nLa librería aprovecha diferentes fuentes de datos públicas como el DENUE y el Censo para estimar variables de uso de suelo y su cambio en el tiempo. Provee métodos para definir tipos de uso de suelo y agregarlo en diferentes unidades espaciales: mallas regulares, hexágonos y polígonos arbitrarios (como colonias o AGEBS)."
  },
  {
    "objectID": "index.html#instalación",
    "href": "index.html#instalación",
    "title": "pyLandUseMX",
    "section": "Instalación",
    "text": "Instalación\nPor lo pronto, la manera más fácil de instalar la librería es usando pip para instalar desde el repositorio. Antes es necesario asegurarse de que las dependencias del sistema están instaladas:\n\ngdal\nrtree\nlibgeos\nproj\n\nEn sistemas basados en apt:\nsudo apt-get install -y gdal-bin python3-gdal python3-rtree libspatialindex-dev libgeos-dev libproj-dev\nYa con las dependencias instaladas:\npip install git+https://github.com/CentroGeo/pyLandUseMX"
  },
  {
    "objectID": "index.html#estructura",
    "href": "index.html#estructura",
    "title": "pyLandUseMX",
    "section": "Estructura",
    "text": "Estructura\nLa librería está organizada en torno a dos conceptos básicos: Cobertura y UsoDeSuelo. Las Coberturas son formas de cubrir un área de estudio (una zona metropolitana, por ejemplo) utilizando mallas regulares (cuadrados o hexágonos) o polígonos de forma arbitraria (colonias o AGEBS, por ejemplo). Estas coberturas definen la forma en la que vamos a agregar variables para estudiar el uso de suelo y proveen los métodos para estas agregaciones. El UsoDeSuelo integra una cobertura y una definición de las variables en torno a categorías definidas por el usuario, a partir de esta integración, la clase UsoDeSuelo provee diferentes herramientas para construir diferentes índices y variables a partir de los datos integrados en las coberturas. El módulo análisis provee métodos para analizar el uso de suelo.\nAdemás de estos elemementos, la librería también contiene un módulo de descargas que permite descargar datos ya procesados que sirven como ejemplo para realizar diferentes tipos de análisis."
  },
  {
    "objectID": "index.html#módulos",
    "href": "index.html#módulos",
    "title": "pyLandUseMX",
    "section": "Módulos",
    "text": "Módulos\n\nDescargas\nEl módulo de descargas, provee funciones para descargar de nuestros repositorios algunas capas que contienen variables relevantes para la extracción y análisis de uso de suelo en México.\nLas funciónes admiten un path en donde descargar los datos. La documentación completa la encuentras en API/descargas\n\nRed de transporte\nTenemos disponible para descargar un recorte de la red de transporte obtenida de OpenStreetMap para la región central del país (la Zona Metropolitana del Valle de México).\n\n\n\nVialidades primarias\n\n\n\n\nPolígonos del Sistema Urbano Nacional\nTambién tenemos disponibles para descarga los polígonos de las ciudades del Sistema Urbano Nacional (SUN) del 2018. Estos representan los límites de las principales aglomeraciones urbanas del país.\n\nColonias CDMX\nTenemos una base de colonias para la CDMX basadas en la que se publica en Datos Abiertos CDMX con algunas correcciones topológicas.\n\n\n\nDENUE\nTenemos una base del DENUE integrada para el año 2022 en la Ciudad de México.\n\n\n\nUso de Suelo\nEl módulo usodesuelo provee métodos para extraer variables de Uso de Suelo y medio construido en diferentes soportes espaciales. Además nos permite calcular algunos índices básicos como mezclas e intensidad.\n\nSoporte\nRegularmente para trabajos sobre análisis de uso de suelo y cobertura urbana se parte de la integración de la información en algún soporte espacial. La clase Soporte provee métodos para estructurar las fuentes de datos en dos grandes tipos de soporte:\n\nMallas regulares\nPolígonos arbitrarios\n\n\n\n\n\n\n\nMalla regular\n\n\n\n\n\n\n\nColonias\n\n\n\n\n\nLos soportes nos permiten agregar diferentes tipos de variables en mallas regulares (por ejemplo, a la izquierda la red de calles agregada en un raster) o en polígonos arbitrarios (a la derecha muestra de comercios agregados en colonias)\n\n\n\n\n\n\nRed agregada en raster\n\n\n\n\n\n\n\nComercios agregados en colonias\n\n\n\n\n\n\n\nUsoDeSuelo\nLa clase UsoDeSuelo parte de un soporte espacial y nos permite calcular algunos indicadores sobre el uso de suelo y el medio construido.\n\n\n\nDENUE\nEste módulo provee funcionalidades para trabajar con datos del Directorio Nacional de Unidades Económicas y obtener algunas variables de uso de suelo. La clase Denue permite seleccionar actividades económicas por clave SCIAN o agregar estas actividades en categorías usando expresiones regulares.\n\n\n\n\n\n\nNote\n\n\n\nEn el módulo descargas se puede obtener una base para la Ciudad de México con el Denue 2022. La estructura de esa base sirve como ejemplo para utilizar otras bases del Denue con la librería"
  }
]