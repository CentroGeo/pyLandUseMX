# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_mallas.ipynb.

# %% auto 0
__all__ = ['Malla']

# %% ../01_mallas.ipynb 3
from fastcore.basics import *
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Polygon
from geocube.api.core import make_geocube
import numpy as np
from .descargas import *
from .denue import *
import warnings

# %% ../01_mallas.ipynb 6
class Malla(object):
    """ Representa una malla para procesar variables de uso de suelo."""
    def __init__(self,
                 size:float=1000, # Tamaño de los elementos de la malla (en las unidades de la proyección de `layer`)
                 grid:gpd.GeoDataFrame=None # La malla vectorial
                ) -> None:
        self.size = size
        self.malla = grid
    
    @classmethod
    def desde_capa(cls, capa, size):
        xmin, ymin, xmax, ymax = capa.total_bounds
        cols = list(np.arange(xmin, xmax + size, size))
        rows = list(np.arange(ymin, ymax + size, size))

        polygons = []
        for x in cols[:-1]:
            for y in rows[:-1]:
                polygons.append(Polygon([(x,y), (x + size, y), (x + size, y + size), (x, y + size)]))

        grid = (gpd
            .GeoDataFrame({'geometry':polygons})
            .set_crs(capa.crs)
            .reset_index()
            .rename({'index':'grid_id'}, axis=1))
        malla = cls(size, grid)
        return malla

# %% ../01_mallas.ipynb 12
@patch
def agrega_puntos(self:Malla,
                  puntos:gpd.GeoDataFrame, # La malla en la que se va a agregar
                  campo: str='cuenta', # Nombre del campo en el que se guarda el resultado
                  clasificacion: str=None # Columna de `puntos` que clasifica a las observaciones. En este caso se agregan
                                          # tantas columnas a la malla como valores distintos haya en la columna
                                          # (en este caso se ignora `campo`)
                ) -> Malla:
    """ Regresa una `Malla` con los conteos de puntos en cada elemento."""
    if self.malla.crs != puntos.crs:
        puntos = puntos.to_crs(self.malla.crs)
    if 'index_right' in puntos.columns:
        puntos = puntos.drop(columns='index_right')
    if clasificacion is None:
        agregado = (puntos
                    .sjoin(self.malla)
                    .groupby('grid_id')
                    .size()
                    .reset_index()
                    .rename({0:campo}, axis=1)
                    .merge(self.malla, on='grid_id', how='right').fillna(0))
        agregado = (gpd.GeoDataFrame(agregado)
                .set_crs(self.malla.crs))
    else:
        agregado = (puntos
                    .sjoin(self.malla)
                    .groupby([clasificacion, 'grid_id'])
                    .size()
                    .reset_index()
                    .pivot(index='grid_id', columns=clasificacion, values=0)                    
                    .merge(self.malla, on='grid_id', how='right')
                    .fillna(0))
    m = Malla(self.size, agregado)
    return m

# %% ../01_mallas.ipynb 24
@patch
def agrega_lineas(self:Malla,
                  lineas:gpd.GeoDataFrame, # La capa de líneas a agregar
                  campo: str='longitud', # Nombre del campo en el que se guarda el resultado
                 ) -> Malla:
    """ Regresa una `Malla` con la longitud de las lineas agregadas en cada elemento."""
    if lineas.crs != self.malla.crs:
        lineas = lineas.to_crs(self.malla.crs) 
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        union = (lineas
                .overlay(self.malla, how='union')
                .dissolve(by='grid_id')
                .length.reset_index()
                .rename({0:campo}, axis=1)   
            )
    union = (self.malla
            .merge(union, on='grid_id', how='left')
            .fillna(0)
        )
    m = Malla(self.size, union)
    return m

# %% ../01_mallas.ipynb 34
@patch
def to_xarray(self:Malla,
              campos: list=None # Lista de campos a convertir, se convierten en bandas del raster
             ):
    """ Regresa un xarray con los `campos` seleccionados como variables."""
    if campos is None:
        campos = [c for c in self.malla.columns if c not in ['geometry', 'grid_id']]     
    cube = make_geocube(vector_data=self.malla, 
                        measurements=campos, 
                        resolution=(self.size, -self.size), 
                       )
    return cube
