# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_coberturas.ipynb.

# %% auto 0
__all__ = ['Cobertura', 'Malla', 'Poligonos']

# %% ../nbs/01_coberturas.ipynb 3
from abc import ABC, abstractmethod
from fastcore.basics import *
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Polygon
from geocube.api.core import make_geocube
import numpy as np
from .descargas import *
from .denue import *
import warnings

# %% ../nbs/01_coberturas.ipynb 6
class Cobertura(ABC):
    """Clase abstracta que define la interfaz para los diferentes tipos de cobertura."""
    @abstractmethod
    def agrega_puntos(self,
                      puntos:gpd.GeoDataFrame,
                      campo:str,
                      clasificacion:str
        ):
        """ Debe proveer la funcionalidad para agregar puntos en los elementos de la cobertura."""
        pass

    @abstractmethod
    def agrega_lineas(self,
                      lineas:gpd.GeoDataFrame,
                      campo:str
        ):
        """ Debe proveer la funcionalidad para agregar líneas en los elementos de la cobertura."""
        pass

# %% ../nbs/01_coberturas.ipynb 8
class Malla(Cobertura):
    """ Representa una malla para procesar variables de uso de suelo."""
    def __init__ (self,
                 datos:gpd.GeoDataFrame=None, # La malla vectorial
                 size:float=1000, # Tamaño de los elementos de la malla (en las unidades de la proyección de `layer`)
        ) -> None:
        self.size = size
        self.datos = datos
    
    @classmethod
    def desde_capa(cls, 
                  capa:gpd.GeoDataFrame, # La capa que define la extensión de la malla 
                  size:float # Tamaño de la mañña en unidades de la proyección
        ):
        xmin, ymin, xmax, ymax = capa.total_bounds
        cols = list(np.arange(xmin, xmax + size, size))
        rows = list(np.arange(ymin, ymax + size, size))

        polygons = []
        for x in cols[:-1]:
            for y in rows[:-1]:
                polygons.append(Polygon([(x,y), (x + size, y), (x + size, y + size), (x, y + size)]))

        grid = (gpd
            .GeoDataFrame({'geometry':polygons})
            .set_crs(capa.crs)
            .reset_index()
            .rename({'index':'grid_id'}, axis=1))
        malla = cls(grid, size)
        return malla

    def agrega_lineas(self, lineas: gpd.GeoDataFrame, campo: str=None):
        pass
    
    def agrega_puntos(self, puntos: gpd.GeoDataFrame, campo: str=None, clasificacion: str=None):
        pass

# %% ../nbs/01_coberturas.ipynb 15
@patch
def agrega_puntos(self:Malla,
                  puntos:gpd.GeoDataFrame, # La malla en la que se va a agregar
                  campo: str='cuenta', # Nombre del campo en el que se guarda el resultado
                  clasificacion: str=None # Columna de `puntos` que clasifica a las observaciones. En este caso se agregan
                                          # tantas columnas a la malla como valores distintos haya en la columna
                                          # (en este caso se ignora `campo`)
                ) -> Malla:
    """ Regresa una `Malla` con los conteos de puntos en cada elemento."""
    if self.datos.crs != puntos.crs:
        puntos = puntos.to_crs(self.datos.crs)
    if 'index_right' in puntos.columns:
        puntos = puntos.drop(columns='index_right')
    if clasificacion is None:
        agregado = (puntos
                    .sjoin(self.datos)
                    .groupby('grid_id')
                    .size()
                    .reset_index()
                    .rename({0:campo}, axis=1)
                    .merge(self.datos, on='grid_id', how='right').fillna(0))
        agregado = (gpd.GeoDataFrame(agregado)
                .set_crs(self.datos.crs))
    else:
        agregado = (puntos
                    .sjoin(self.datos)
                    .groupby([clasificacion, 'grid_id'])
                    .size()
                    .reset_index()
                    .pivot(index='grid_id', columns=clasificacion, values=0)                    
                    .merge(self.datos, on='grid_id', how='right')
                    .fillna(0))
    m = Malla(agregado, self.size)
    return m

# %% ../nbs/01_coberturas.ipynb 27
@patch
def agrega_lineas(self:Malla,
                  lineas:gpd.GeoDataFrame, # La capa de líneas a agregar
                  campo: str='longitud', # Nombre del campo en el que se guarda el resultado
                 ) -> Malla:
    """ Regresa una `Malla` con la longitud de las lineas agregadas en cada elemento."""
    if lineas.crs != self.datos.crs:
        lineas = lineas.to_crs(self.datos.crs) 
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        union = (lineas
                .overlay(self.datos, how='union')
                .dissolve(by='grid_id')
                .length.reset_index()
                .rename({0:campo}, axis=1)   
            )
    union = (self.datos
            .merge(union, on='grid_id', how='left')
            .fillna(0)
        )
    m = Malla(union, self.size)
    return m

# %% ../nbs/01_coberturas.ipynb 37
@patch
def to_xarray(self:Malla,
              campos: list=None # Lista de campos a convertir, se convierten en bandas del raster
             ):
    """ Regresa un xarray con los `campos` seleccionados como variables."""
    if campos is None:
        campos = [c for c in self.datos.columns if c not in ['geometry', 'grid_id']]     
    cube = make_geocube(vector_data=self.datos, 
                        measurements=campos, 
                        resolution=(self.size, -self.size), 
                       )
    return cube

# %% ../nbs/01_coberturas.ipynb 43
class Poligonos(Cobertura):
    """ Representa una cobertura de polígonos de forma arbitraria 
        para procesar variables de uso de suelo."""
    def __init__ (self,
                 datos:gpd.GeoDataFrame=None, # La malla vectorial
                 id_col:str=None, # Columna que se va a usar para identificar a cada polígono
        ) -> None:
        self.id_col = id_col
        self.datos = datos
    
    @classmethod
    def desde_archivo(cls,
                      path:str, # Path al archivo de datos (cualquiera soportado por GeoPandas), 
                      id_col:str,  # Columna que se va a usar para identificar a cada polígono
                      layer=None
        ):
        gdf = gpd.read_file(path)
        return cls(gdf, id_col)

    def agrega_lineas(self, lineas: gpd.GeoDataFrame, campo: str=None):
        pass
    
    def agrega_puntos(self, puntos: gpd.GeoDataFrame, campo: str=None, clasificacion: str=None):
        pass    

# %% ../nbs/01_coberturas.ipynb 48
@patch
def agrega_puntos(self:Poligonos,
                  puntos:gpd.GeoDataFrame, # La malla en la que se va a agregar
                  campo: str='cuenta', # Nombre del campo en el que se guarda el resultado
                  clasificacion: str=None # Columna de `puntos` que clasifica a las observaciones. En este caso se agregan
                                          # tantas columnas a la malla como valores distintos haya en la columna
                                          # (en este caso se ignora `campo`)
                ) -> Poligonos:
    """ Regresa un `Poligonos` con los conteos de puntos en cada unidad."""
    if self.datos.crs != puntos.crs:
        puntos = puntos.to_crs(self.datos.crs)
    if 'index_right' in puntos.columns:
        puntos = puntos.drop(columns='index_right')
    if self.id_col in puntos.columns:
        puntos = puntos.drop(columns=self.id_col)
    if clasificacion is None:
        agregado = (puntos
                    .sjoin(self.datos)
                    .groupby(self.id_col)
                    .size()
                    .reset_index()
                    .rename({0:campo}, axis=1)
                    .merge(self.datos, on=self.id_col, how='right').fillna(0))
        agregado = (gpd.GeoDataFrame(agregado)
                       .set_crs(self.datos.crs))
    else:
        agregado = (puntos
                    .sjoin(self.datos)
                    .groupby([clasificacion, self.id_col])
                    .size()
                    .reset_index()
                    .pivot(index=self.id_col, columns=clasificacion, values=0)                    
                    .merge(self.datos, on=self.id_col, how='right')
                    .fillna(0))
    p = Poligonos(agregado, self.id_col)
    return p
